{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"NeKo \u2013 Network Konstructor","text":"<p>NeKo is a Python package for extracting, visualising, converting, and studying interactions from databases into executable activity flow-based models. It is built on top of OmniPath, PyPath, and Atopo.</p>"},{"location":"#key-features","title":"Key features","text":"Feature Description Network creation Build signalling networks from curated prior-knowledge databases Node connection Connect nodes and subnetworks with flexible stepwise strategies Gene-to-phenotype Map gene sets to phenotypic categories via Gene Ontology Visualisation Render networks with Graphviz or the interactive yFiles widget Export Export to SIF, GML, GraphML, BND/CFG logical model formats Network history Automatic snapshots, branching state management, and HTML/SVG rendering Comparison Compare two networks and highlight differences"},{"location":"#citation","title":"Citation","text":"<p>If you use NeKo in your research, please cite:</p> <p>Ruscone M, Tsirvouli E, Checcoli A, Turei D, Barillot E, et al. (2025) NeKo: A tool for automatic network construction from prior knowledge. PLOS Computational Biology 21(9): e1013300. https://doi.org/10.1371/journal.pcbi.1013300</p>"},{"location":"#quick-start","title":"Quick start","text":"<pre><code>from neko.core.network import Network\nfrom neko.inputs import Universe\nfrom neko._visual.visualize_network import NetworkVisualizer\n\n# Load the interaction universe from OmniPath\nresources = Universe()\nresources.build()\n\n# Create a network from a list of genes\nnet = Network([\"EGFR\", \"KRAS\", \"TP53\", \"AKT1\"], resources=resources.interactions)\n\n# Connect nodes using the available database interactions\nnet.connect_nodes()\n\n# Visualise\nvis = NetworkVisualizer(net)\nvis.render()\n</code></pre> <p>See the Tutorials for full worked examples, or jump to the API Reference for detailed documentation.</p>"},{"location":"#comparison-with-sphinx-docs","title":"Comparison with Sphinx docs","text":"<p>During the transition period both documentation backends are live. Feel free to use whichever you prefer and let us know via a GitHub issue:</p> <ul> <li>This site (MkDocs / Material) \u2013 https://sysbio-curie.github.io/Neko/</li> <li>Sphinx / RTD \u2013 https://sysbio-curie.github.io/Neko/sphinx/</li> </ul>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to NeKo are documented here. The format follows Keep a Changelog and the project adheres to Semantic Versioning.</p>"},{"location":"changelog/#110-2025","title":"[1.1.0] \u2013 2025","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Branching NetworkHistory with automatic state snapshots and HTML/SVG rendering</li> <li><code>NetworkState</code> class for point-in-time network snapshots</li> <li>BFS / DFS graph traversal algorithms in <code>neko.core.algorithms</code></li> <li><code>connect_to_upstream_nodes</code> method</li> <li>Performance benchmarking scripts</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Interaction lookup tables pre-processed for O(1) neighbour queries</li> <li><code>connect_nodes</code> signature updated for clarity</li> <li><code>pandas</code> pinned to <code>2.2.2</code> for stability</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Edge colouring bug in <code>NetworkVisualizer.vis_comparison</code></li> <li>Handling of complex node names containing colons</li> </ul>"},{"location":"changelog/#100-2024","title":"[1.0.0] \u2013 2024","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Initial public release on PyPI as nekomata</li> <li>Core <code>Network</code> class with <code>add_node</code>, <code>add_edge</code>, <code>remove_node</code></li> <li><code>connect_nodes</code>, <code>connect_subgroup</code>, <code>connect_component</code>, <code>complete_connection</code></li> <li><code>connect_genes_to_phenotype</code> via Gene Ontology</li> <li><code>NetworkVisualizer</code> with Graphviz and yFiles backends</li> <li><code>Exports</code> class: BNet and SIF formats</li> <li><code>Ontology</code> class for GO-term and tissue mapping</li> <li>11 tutorial notebooks</li> <li>Sphinx documentation hosted on GitHub Pages</li> </ul>"},{"location":"changelog/#0x-pre-release","title":"[0.x] \u2013 Pre-release","text":"<p>Internal development versions at Institut Curie / Sysbio-Curie.</p>"},{"location":"contributing/","title":"Contributing","text":"<p>We welcome contributions of all kinds \u2014 bug reports, documentation fixes, new features, and new database connectors.</p>"},{"location":"contributing/#development-setup","title":"Development setup","text":"<pre><code>git clone https://github.com/sysbio-curie/Neko.git\ncd Neko\npoetry install\npre-commit install\n</code></pre>"},{"location":"contributing/#code-style","title":"Code style","text":"<p>NeKo uses the following formatters and linters (enforced via pre-commit):</p> Tool Purpose black Code formatting autopep8 PEP 8 compliance isort Import ordering flake8 Error / style linting prettier YAML / JSON / Markdown formatting <p>Run checks manually:</p> <pre><code>pre-commit run --all-files\n</code></pre>"},{"location":"contributing/#running-tests","title":"Running tests","text":"<pre><code>pytest tests/\n# or with coverage:\npytest --cov=neko tests/\n</code></pre>"},{"location":"contributing/#docstring-style","title":"Docstring style","text":"<p>NeKo uses NumPy-style docstrings:</p> <pre><code>def my_function(x: int, y: float) -&gt; str:\n    \"\"\"\n    One-line summary.\n\n    Longer description if needed.\n\n    Parameters\n    ----------\n    x : int\n        Description of x.\n    y : float\n        Description of y.\n\n    Returns\n    -------\n    str\n        Description of the return value.\n    \"\"\"\n</code></pre>"},{"location":"contributing/#pull-request-checklist","title":"Pull request checklist","text":"<ul> <li>[ ] Tests pass (<code>pytest tests/</code>)</li> <li>[ ] New code is covered by tests</li> <li>[ ] Docstrings follow NumPy style</li> <li>[ ] <code>pre-commit run --all-files</code> passes</li> <li>[ ] Changelog entry added</li> </ul>"},{"location":"contributing/#reporting-issues","title":"Reporting issues","text":"<p>Open a GitHub issue and include:</p> <ol> <li>NeKo version (<code>python -c \"import neko; print(neko.__version__)\"</code>)</li> <li>Python version</li> <li>OS</li> <li>Minimal reproducible example</li> </ol>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#requirements","title":"Requirements","text":"<p>NeKo requires Python \u2265 3.10.</p>"},{"location":"installation/#install-from-pypi-recommended","title":"Install from PyPI (recommended)","text":"<pre><code>pip install nekomata\n</code></pre> <p>Package name</p> <p>The PyPI package is called nekomata \u2014 <code>pip install neko</code> and <code>pip install pyneko</code> are unrelated packages.</p>"},{"location":"installation/#install-from-source","title":"Install from source","text":"<p>For the latest development version:</p> <pre><code>git clone https://github.com/sysbio-curie/Neko.git\ncd Neko\npip install .\n</code></pre>"},{"location":"installation/#optional-install-with-poetry","title":"Optional: install with Poetry","text":"<pre><code>git clone https://github.com/sysbio-curie/Neko.git\ncd Neko\npoetry install\n</code></pre>"},{"location":"installation/#system-dependencies","title":"System dependencies","text":""},{"location":"installation/#graphviz","title":"Graphviz","text":"<p>Graphviz is required for network rendering. Install it with your system package manager before installing NeKo.</p> Linux (apt)macOS (Homebrew)Windows (Chocolatey) <pre><code>sudo apt-get install python3-dev graphviz libgraphviz-dev\n</code></pre> <pre><code>brew install graphviz\n</code></pre> <pre><code>choco install graphviz\n</code></pre> <p>More information: https://graphviz.org/download/</p>"},{"location":"installation/#pandoc-optional-for-notebook-export","title":"Pandoc (optional, for notebook export)","text":"<pre><code>sudo apt-get install pandoc   # Linux\nbrew install pandoc           # macOS\n</code></pre>"},{"location":"installation/#verify-installation","title":"Verify installation","text":"<pre><code>import neko\nprint(neko.__version__)\n</code></pre>"},{"location":"installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"installation/#graphviz-import-errors","title":"<code>graphviz</code> import errors","text":"<p>If <code>import graphviz</code> fails, ensure the system Graphviz binary is on your <code>PATH</code>:</p> <pre><code>which dot   # should point to the graphviz dot binary\n</code></pre>"},{"location":"installation/#omnipath-pypath-connectivity","title":"OmniPath / PyPath connectivity","text":"<p>NeKo downloads interaction data from the OmniPath web service on first use. Ensure you have a working internet connection when calling <code>Universe().build()</code>.</p>"},{"location":"api/","title":"API Reference","text":"<p>NeKo's public API is organised into five main areas:</p> Module Description <code>neko.core.network.Network</code> Core class \u2013 build, manipulate, and query a signalling network <code>neko._visual.visualize_network.NetworkVisualizer</code> Render networks with Graphviz or the yFiles widget <code>neko._methods.enrichment_methods.Connections</code> Algorithms for enriching a network from an interaction database <code>neko._annotations.gene_ontology.Ontology</code> Gene Ontology utilities and phenotype mapping <code>neko._outputs.exports</code> Export helpers (SIF, GML, GraphML, BND/CFG)"},{"location":"api/#design-philosophy","title":"Design philosophy","text":"<p>NeKo follows a Network-centric design:</p> <ol> <li>Start with a list of gene/protein identifiers.</li> <li>Attach an interaction <code>Universe</code> from OmniPath (or custom CSV/DataFrame).</li> <li>Use <code>Network</code> methods to connect, expand, and annotate nodes.</li> <li>Visualise or export the result.</li> </ol> <p>All mutation methods on <code>Network</code> automatically create a snapshot in the branching NetworkHistory, so every intermediate state is recoverable.</p>"},{"location":"api/#import-conventions","title":"Import conventions","text":"<pre><code># Core\nfrom neko.core.network import Network\n\n# Visualisation\nfrom neko._visual.visualize_network import NetworkVisualizer\n\n# Interaction universe\nfrom neko.inputs import Universe\n\n# Ontology\nfrom neko._annotations.gene_ontology import Ontology\n</code></pre>"},{"location":"api/connections/","title":"Connections","text":"<p><code>Connections</code> provides the search-and-connect algorithms that underlie <code>Network</code> expansion methods. It is initialised with an interaction database DataFrame and pre-processes lookup tables for fast neighbour queries.</p> <p>You rarely need to instantiate <code>Connections</code> directly \u2014 it is used internally by <code>Network</code>. The documentation here is aimed at developers who want to extend NeKo with custom connection strategies.</p>"},{"location":"api/connections/#import","title":"Import","text":"<pre><code>from neko._methods.enrichment_methods import Connections\n</code></pre>"},{"location":"api/connections/#quick-example","title":"Quick example","text":"<pre><code>import pandas as pd\nfrom neko._methods.enrichment_methods import Connections\n\ndb = pd.read_csv(\"my_interactions.csv\")   # source, target, effect, ...\nconn = Connections(db)\n\n# Check if a direct path exists between two proteins\npaths = conn.find_paths(\"EGFR\", \"AKT1\", maxlen=3)\n</code></pre>"},{"location":"api/connections/#class-reference","title":"Class reference","text":""},{"location":"api/connections/#neko._methods.enrichment_methods.Connections","title":"Connections","text":"<pre><code>Connections(database: DataFrame)\n</code></pre> <p>Class that stores many utility functions to enrich an object Network. Each utility functions should take as input the nodes dataframe, which is used as base for each algorithm, and a database from the inputs modules, which will be used to extend the initial network.</p> Source code in <code>neko/_methods/enrichment_methods.py</code> <pre><code>def __init__(self, database: pd.DataFrame):\n    self.resources = database.copy()\n    self.target_neighbours_map = self._preprocess_target_neighbours()\n    self.source_neighbours_map = self._preprocess_source_neighbours()\n    # Precompute edge sign cache for both consensus True/False\n    self.signed_edges = {}\n    self.signed_edges_consensus = {}\n    for _, row in self.resources.iterrows():\n        key = (row['source'], row['target'])\n        self.signed_edges[key] = check_sign(row, consensus=False) != \"undefined\"\n        self.signed_edges_consensus[key] = check_sign(row, consensus=True) != \"undefined\"\n</code></pre>"},{"location":"api/connections/#neko._methods.enrichment_methods.Connections-functions","title":"Functions","text":""},{"location":"api/connections/#neko._methods.enrichment_methods.Connections.find_target_neighbours","title":"find_target_neighbours","text":"<pre><code>find_target_neighbours(node: str) -&gt; List[str]\n</code></pre> <p>Optimized helper function that finds the neighbors of the target node.</p> Source code in <code>neko/_methods/enrichment_methods.py</code> <pre><code>def find_target_neighbours(self, node: str) -&gt; List[str]:\n    \"\"\"\n    Optimized helper function that finds the neighbors of the target node.\n    \"\"\"\n    return list(self.target_neighbours_map.get(node, []))\n</code></pre>"},{"location":"api/connections/#neko._methods.enrichment_methods.Connections.find_source_neighbours","title":"find_source_neighbours","text":"<pre><code>find_source_neighbours(node: str) -&gt; List[str]\n</code></pre> <p>Optimized helper function that finds the neighbors of the target node.</p> Source code in <code>neko/_methods/enrichment_methods.py</code> <pre><code>def find_source_neighbours(self, node: str) -&gt; List[str]:\n    \"\"\"\n    Optimized helper function that finds the neighbors of the target node.\n    \"\"\"\n    return list(self.source_neighbours_map.get(node, []))\n</code></pre>"},{"location":"api/connections/#neko._methods.enrichment_methods.Connections.find_all_neighbours","title":"find_all_neighbours","text":"<pre><code>find_all_neighbours(node: str) -&gt; List[str]\n</code></pre> <p>Optimized helper function that finds all neighbors (both source and target) of the target node.</p> Source code in <code>neko/_methods/enrichment_methods.py</code> <pre><code>def find_all_neighbours(self, node: str) -&gt; List[str]:\n    \"\"\"\n    Optimized helper function that finds all neighbors (both source and target) of the target node.\n    \"\"\"\n    target_neighs = self.find_target_neighbours(node)\n    source_neighs = self.find_source_neighbours(node)\n    return list(set(target_neighs + source_neighs))\n</code></pre>"},{"location":"api/connections/#neko._methods.enrichment_methods.Connections.is_signed_edge","title":"is_signed_edge","text":"<pre><code>is_signed_edge(source, target, consensus=False)\n</code></pre> <p>Returns True if the edge from source to target is signed (not undefined), False otherwise. Uses precomputed cache for speed.</p> Source code in <code>neko/_methods/enrichment_methods.py</code> <pre><code>def is_signed_edge(self, source, target, consensus=False):\n    \"\"\"\n    Returns True if the edge from source to target is signed (not undefined), False otherwise.\n    Uses precomputed cache for speed.\n    \"\"\"\n    key = (source, target)\n    if consensus:\n        result = self.signed_edges_consensus.get(key, False)\n    else:\n        result = self.signed_edges.get(key, False)\n    return result\n</code></pre>"},{"location":"api/connections/#neko._methods.enrichment_methods.Connections.bfs","title":"bfs","text":"<pre><code>bfs(start: str, end: str, maxlen: Optional[int], only_signed: bool = False, consensus: bool = False, force: bool = False) -&gt; List[List[str]]\n</code></pre> <p>Returns the shortest path between two nodes (as a list of nodes) using BFS, but stops searching if the path length exceeds <code>maxlen</code> edges (if provided). If only_signed is True, only considers signed edges (not undefined). If force is False and maxlen is None, uses a default upper bound of 10.</p> Source code in <code>neko/_methods/enrichment_methods.py</code> <pre><code>def bfs(self, start: str, end: str, maxlen: Optional[int], only_signed: bool = False, consensus: bool = False, force: bool = False) -&gt; List[List[str]]:\n    \"\"\"\n    Returns the shortest path between two nodes (as a list of nodes) using BFS,\n    but stops searching if the path length exceeds `maxlen` edges (if provided).\n    If only_signed is True, only considers signed edges (not undefined).\n    If force is False and maxlen is None, uses a default upper bound of 10.\n    \"\"\"\n    if start == end:\n        return [[start]]  # trivial path\n\n    visited = set()\n    # Set a default upper bound if maxlen is None and not force\n    effective_maxlen = maxlen\n    if maxlen is None and not force:\n        effective_maxlen = 10\n    queue = deque([(start, [start], 0)])  # (node, path_so_far, depth)\n\n    while queue:\n        node, path, depth = queue.popleft()\n        if node == end:\n            return [path]\n        if effective_maxlen is not None and depth &gt;= effective_maxlen:\n            continue\n        if node not in visited:\n            visited.add(node)\n            for neighbor in self.find_target_neighbours(node):\n                if neighbor not in visited:\n                    if not only_signed or self.is_signed_edge(node, neighbor, consensus):\n                        queue.append((neighbor, path + [neighbor], depth + 1))\n    return []\n</code></pre>"},{"location":"api/connections/#neko._methods.enrichment_methods.Connections.find_paths","title":"find_paths","text":"<pre><code>find_paths(start: Union[str, DataFrame, List[str]], end: Union[str, DataFrame, List[str], None] = None, maxlen: int = 2, minlen: int = 1, loops: bool = False, only_signed: bool = False, consensus: bool = False) -&gt; List[List[str]]\n</code></pre> <p>Find all paths or motifs in a network, with optional sign/consensus filtering. Uses an iterative DFS with an explicit stack for better performance and memory efficiency. Args:     start: Node(s) to start from (str, list of str, or DataFrame with 'name_of_node').     end: Node(s) to end at (str, list of str, DataFrame, or None for motif search).     maxlen: Maximum path length (number of edges).     minlen: Minimum path length (number of edges).     loops: Allow cycles/loops if True.     only_signed: If True, only consider signed edges (not undefined).     consensus: If True, use consensus sign filtering. Returns:     List of paths (each path is a list of node names).</p> Source code in <code>neko/_methods/enrichment_methods.py</code> <pre><code>def find_paths(self,\n               start: Union[str, pd.DataFrame, List[str]],\n               end: Union[str, pd.DataFrame, List[str], None] = None,\n               maxlen: int = 2,\n               minlen: int = 1,\n               loops: bool = False,\n               only_signed: bool = False,\n               consensus: bool = False) -&gt; List[List[str]]:\n    \"\"\"\n    Find all paths or motifs in a network, with optional sign/consensus filtering.\n    Uses an iterative DFS with an explicit stack for better performance and memory efficiency.\n    Args:\n        start: Node(s) to start from (str, list of str, or DataFrame with 'name_of_node').\n        end: Node(s) to end at (str, list of str, DataFrame, or None for motif search).\n        maxlen: Maximum path length (number of edges).\n        minlen: Minimum path length (number of edges).\n        loops: Allow cycles/loops if True.\n        only_signed: If True, only consider signed edges (not undefined).\n        consensus: If True, use consensus sign filtering.\n    Returns:\n        List of paths (each path is a list of node names).\n    \"\"\"\n\n    def convert_to_string_list(start):\n        if isinstance(start, str):\n            return [start]\n        elif isinstance(start, pd.DataFrame):\n            return start['name_of_node'].tolist()\n        elif isinstance(start, list) and all(isinstance(item, str) for item in start):\n            return start\n        else:\n            raise ValueError(\"Invalid type for 'start' variable\")\n\n    def path_generator(start_nodes, end_nodes, maxlen, minlen, loops, only_signed, consensus):\n        for s in start_nodes:\n            for e in end_nodes:\n                stack = [(s, [s])]\n                while stack:\n                    current, path = stack.pop()\n                    # Prune if path too long\n                    if len(path) &gt; maxlen + 1:\n                        continue\n                    # Check for valid path\n                    if len(path) &gt;= minlen + 1 and (\n                        (e is not None and current == e) or\n                        (e is None and not loops and len(path) == maxlen + 1) or\n                        (loops and path[0] == path[-1] and len(path) &gt; 1)\n                    ):\n                        yield path\n                    # Continue DFS\n                    if len(path) &lt;= maxlen:\n                        next_steps = self.find_target_neighbours(current)\n                        if only_signed:\n                            next_steps = [n for n in next_steps if self.is_signed_edge(current, n, consensus)]\n                        if not loops:\n                            next_steps = list(set(next_steps) - set(path))\n                        for neighbor in next_steps:\n                            stack.append((neighbor, path + [neighbor]))\n\n    start_nodes = convert_to_string_list(start)\n    end_nodes = convert_to_string_list(end) if end else [None]\n    minlen = max(1, minlen)\n    # Collect all paths in a list for backward compatibility\n    return list(path_generator(start_nodes, end_nodes, maxlen, minlen, loops, only_signed, consensus))\n</code></pre>"},{"location":"api/connections/#neko._methods.enrichment_methods.Connections.find_upstream_cascades","title":"find_upstream_cascades","text":"<pre><code>find_upstream_cascades(target_genes: List[str], max_depth: int = 1, selected_rank: int = 1) -&gt; List[Tuple[str, str]]\n</code></pre> <p>Find cascades of interactions in the network. Parameters: - target_genes: List of target genes to start the cascade. - max_depth: Maximum depth of the cascade. - selected_rank: Number of top regulators to select for each iteration. Returns: - interactions: List of interactions in the cascade.</p> Source code in <code>neko/_methods/enrichment_methods.py</code> <pre><code>def find_upstream_cascades(self,\n                           target_genes: List[str],\n                           max_depth: int = 1,\n                           selected_rank: int = 1) -&gt; List[Tuple[str, str]]:\n    \"\"\"\n    Find cascades of interactions in the network.\n    Parameters:\n    - target_genes: List of target genes to start the cascade.\n    - max_depth: Maximum depth of the cascade.\n    - selected_rank: Number of top regulators to select for each iteration.\n    Returns:\n    - interactions: List of interactions in the cascade.\n    \"\"\"\n\n    def collect_for_depth(current_targets, current_depth):\n        if current_depth &gt; max_depth:\n            return []\n\n        mcs_regulators = find_minimal_covering_regulators(self.resources, current_targets, selected_rank)\n\n        interactions = [(reg, target) for reg in mcs_regulators for target in self.target_neighbours_map.get(reg, []) if target in current_targets]  # this is not working\n\n        if current_depth &lt; max_depth:\n            next_targets = list(mcs_regulators)\n            interactions += collect_for_depth(next_targets, current_depth + 1)\n\n        return interactions\n\n    return collect_for_depth(target_genes, 1) # it returns nothing\n</code></pre>"},{"location":"api/exports/","title":"Exports","text":"<p><code>Exports</code> converts a <code>Network</code> object into various file formats used by modelling tools such as MaBoSS, GINsim, and CoBrexa.</p>"},{"location":"api/exports/#import","title":"Import","text":"<pre><code>from neko._outputs.exports import Exports\n</code></pre>"},{"location":"api/exports/#supported-formats","title":"Supported formats","text":"Format Method Tool BNet (Boolean Network) <code>export_bnet()</code> MaBoSS, PyBoolNet SIF (Simple Interaction Format) <code>export_sif()</code> Cytoscape GML via <code>networkx</code> on <code>net.graph</code> Various GraphML via <code>networkx</code> on <code>net.graph</code> Gephi, yEd"},{"location":"api/exports/#quick-example","title":"Quick example","text":"<pre><code>from neko._outputs.exports import Exports\n\nexporter = Exports(net)\n\n# Export to BNet format for MaBoSS\nexporter.export_bnet(\"my_model.bnet\")\n\n# Export to SIF for Cytoscape\nexporter.export_sif(\"my_network.sif\")\n</code></pre> <p>Exporting directly from <code>Network</code></p> <p>The convenience wrappers on <code>Network</code> call <code>Exports</code> internally, so in most cases you do not need to instantiate <code>Exports</code> yourself:</p> <pre><code>net.export_bnet(\"model.bnet\")\n</code></pre>"},{"location":"api/exports/#class-reference","title":"Class reference","text":""},{"location":"api/exports/#neko._outputs.exports.Exports","title":"Exports","text":"<pre><code>Exports(network)\n</code></pre> <p>This class implement many methods used to export the Network object in different format. In particular the exports format will be methods-oriented (MaBoSS, Ginsim, cobrexa and so on...). To start with, the user can export the Network in SIF and Bnet format. In the future many more versatile methods will be implemented (SBML) and annotations will be included for each interaction, including the DOI of the relative reference and annotations from each database</p> Source code in <code>neko/_outputs/exports.py</code> <pre><code>def __init__(self, network):\n    net = network.copy()\n    df_edges = net.convert_edgelist_into_genesymbol()\n    self.nodes = net.nodes\n    self.interactions = df_edges\n    return\n</code></pre>"},{"location":"api/exports/#neko._outputs.exports.Exports-functions","title":"Functions","text":""},{"location":"api/exports/#neko._outputs.exports.Exports.export_bnet","title":"export_bnet","text":"<pre><code>export_bnet(file_name='logic_model.bnet')\n</code></pre> <p>Function to export the network in bnet format, creating multiple files for bimodal interactions.</p> Source code in <code>neko/_outputs/exports.py</code> <pre><code>def export_bnet(self, file_name=\"logic_model.bnet\"):\n    \"\"\"\n    Function to export the network in bnet format, creating multiple files for bimodal interactions.\n    \"\"\"\n    # Checks for nodes and interactions data\n    if not isinstance(self.nodes, pd.DataFrame) or self.nodes.empty:\n        print(\"Error: Nodes data is missing or empty.\")\n        return\n    if not isinstance(self.interactions, pd.DataFrame) or self.interactions.empty:\n        print(\"Error: Interactions data is missing or empty.\")\n        return\n\n    # Identify undefined interactions\n    undefined_interactions = self.interactions.query(\"Effect == 'undefined'\")\n    if not undefined_interactions.empty:\n        print(f\"Warning: The network has {len(undefined_interactions)} UNDEFINED interaction(s).\")\n        print(\"Undefined interactions:\")\n        for index, row in undefined_interactions.iterrows():\n            print(f\"{row['source']} -&gt; {row['target']}\")\n            print(f\"Reference: {row['References']}\")\n\n    # Identify bimodal interactions\n    bimodal_interactions = self.interactions.query(\"Effect == 'bimodal'\")\n    if not bimodal_interactions.empty:\n        print(f\"Warning: The network has {len(bimodal_interactions)} BIMODAL interaction(s).\")\n        print(\"Bimodal interactions:\")\n        for index, row in bimodal_interactions.iterrows():\n            print(f\"{row['source']} -&gt; {row['target']}\")\n            print(f\"Reference: {row['References']}\")\n\n    # Generate permutations for bimodal interactions\n    bimodal_sources = bimodal_interactions['source'].tolist()\n    bimodal_targets = bimodal_interactions['target'].tolist()\n    permutations = list(itertools.product(['stimulation', 'inhibition'], repeat=len(bimodal_interactions)))\n\n    # Create a directory for the BNet files if a directory is provided\n    directory = os.path.dirname(file_name)\n    if directory:\n        os.makedirs(directory, exist_ok=True)\n\n    # Iterate through permutations and create a BNet file for each\n    for i, perm in enumerate(permutations):\n        # Create a copy of the interactions DataFrame\n        interactions_copy = self.interactions.copy()\n\n        # Update bimodal interactions based on the current permutation\n        for j, (source, target) in enumerate(zip(bimodal_sources, bimodal_targets)):\n            interactions_copy.loc[(interactions_copy['source'] == source) &amp;\n                                  (interactions_copy['target'] == target), 'Effect'] = perm[j]\n\n        # Pre-filter stimulations, inhibitions, and exclude undefined effects\n        stimulations = interactions_copy.query(\"Effect == 'stimulation'\")\n        inhibitions = interactions_copy.query(\"Effect == 'inhibition'\")\n        complex_formation = interactions_copy.query(\"Effect == 'form complex'\")\n\n        # Generate the file name for this permutation\n        perm_file_name = f\"{os.path.splitext(file_name)[0]}_{i + 1}.bnet\"\n\n        with open(perm_file_name, \"w\") as f:\n            f.write(\"# model in BoolNet format\\n\")\n            f.write(\"targets, factors\\n\")\n\n            for entry in self.nodes.values:\n                node = entry[0]\n\n                # Replace special characters in node names\n                node = re.sub(r\"[\\/\\-\\s\\#]\", \"_\", node)\n\n                formula_on = [re.sub(r\"[\\/\\-\\s\\#]\", \"_\", src) for src in\n                              stimulations[stimulations[\"target\"] == node][\"source\"].to_list()]\n                formula_off = [re.sub(r\"[\\/\\-\\s\\#]\", \"_\", src) for src in\n                               inhibitions[inhibitions[\"target\"] == node][\"source\"].to_list()]\n                formula_complex = [re.sub(r\"[\\/\\-\\s\\#]\", \"_\", src) for src in\n                                   complex_formation[complex_formation[\"target\"] == node][\"source\"].to_list()]\n\n                # Constructing the formula\n                formula_parts = []\n                if formula_complex:\n                    formula_parts.append(f\"({' &amp; '.join(formula_complex)})\")\n                if formula_on:\n                    formula_parts.append(f\"({' | '.join(formula_on)})\")\n                if formula_off:\n                    formula_parts.append(\"!({})\".format(\" | \".join(formula_off)))\n\n                # Writing the node and its formula to the file\n                f.write(f\"{node}, {' &amp; '.join(formula_parts) if formula_parts else node}\\n\")\n\n        print(f\"Created BNet file: {perm_file_name}\")\n\n    print(f\"Generated {len(permutations)} BNet files.\")\n</code></pre>"},{"location":"api/exports/#neko._outputs.exports.Exports.export_sif","title":"export_sif","text":"<pre><code>export_sif(file_name='logic_model.sif')\n</code></pre> <p>Function to export the network in SIF format</p> Source code in <code>neko/_outputs/exports.py</code> <pre><code>def export_sif(self, file_name=\"logic_model.sif\"):\n    \"\"\"\n    Function to export the network in SIF format\n    \"\"\"\n\n    with open(file_name, 'w') as file:\n        for index, row in self.interactions.iterrows():\n            # Use the Effect column directly assuming it contains \"activate\" or \"inhibit\"\n            interaction_type = row['Effect']\n\n            if interaction_type == \"form complex\":\n                interaction_type = \"form_complex\"\n\n            # Reference for the interaction\n            interaction_reference = row['References']  # Adjust column name if necessary\n\n            # Write a comment line with the interaction reference\n            file.write(f\"# Reference PMID: {interaction_reference}\\n\")\n\n            # Write the formatted interaction to the .sif file\n            file.write(f\"{row['source']}\\t{interaction_type}\\t{row['target']}\\n\")\n\n    return\n</code></pre>"},{"location":"api/network/","title":"Network","text":"<p>The <code>Network</code> class is the central object in NeKo. It holds a directed graph of biological nodes (genes, proteins, complexes) and edges (interactions), and exposes methods for expanding, connecting, querying, and exporting those graphs.</p>"},{"location":"api/network/#import","title":"Import","text":"<pre><code>from neko.core.network import Network\n</code></pre>"},{"location":"api/network/#quick-example","title":"Quick example","text":"<pre><code>from neko.core.network import Network\nfrom neko.inputs import Universe\n\nresources = Universe()\nresources.build()\n\nnet = Network([\"EGFR\", \"KRAS\", \"MYC\"], resources=resources.interactions)\nnet.connect_nodes()\nprint(net.nodes)\nprint(net.edges)\n</code></pre>"},{"location":"api/network/#class-reference","title":"Class reference","text":""},{"location":"api/network/#neko.core.network.Network","title":"Network","text":"<pre><code>Network(initial_nodes: list[str] = None, sif_file=None, resources=None)\n</code></pre> <p>A molecular interaction network.</p> <pre><code>The `Network` object is the central organizing component of the `neko`\nmodule. It is the subject of all operations implemented here, including\ntopological algorithms, graph analysis, network visualization and\nintegration of database knowledge.\n</code></pre> <p>Args:     initial_nodes: A list of initial nodes to be added to the network.     sif_file: A SIF (Simple Interaction Format) file to load the network from.     resources: A pandas DataFrame containing the resources database.</p> <p>Methods:</p> Source code in <code>neko/core/network.py</code> <pre><code>def __init__(\n        self,\n        initial_nodes: list[str] = None,\n        sif_file=None,\n        resources=None,\n    ):\n\n    self._init_args = locals()\n    del self._init_args['self']\n    self.nodes = pd.DataFrame(columns=[\"Genesymbol\", \"Uniprot\", \"Type\"])\n    self.edges = pd.DataFrame(columns=[\"source\", \"target\", \"Type\", \"Effect\", \"References\"])\n    # Internal object-based storage\n    self._node_objs = set()  # Set of Node objects\n    self._edge_objs = set()  # Set of Edge objects\n    self.initial_nodes = initial_nodes\n    self._ontology = Ontology()\n    # --- NetworkState history tracking ---\n    self._states: dict[int, NetworkState] = {}\n    self._state_metadata: dict[int, dict] = {}\n    self._state_log: list[int] = []\n    self._state_counter: int = 0\n    self._current_state_id: Optional[int] = None\n    self._root_state_id: Optional[int] = None\n    self._auto_state_depth: int = 0\n    self._history_enabled: bool = True\n    self._max_history: Optional[int] = None\n    self._is_initializing = True\n    self._populate()\n    self._is_initializing = False\n</code></pre>"},{"location":"api/network/#neko.core.network.Network-functions","title":"Functions","text":""},{"location":"api/network/#neko.core.network.Network.add_node","title":"add_node","text":"<pre><code>add_node(node: str, from_sif: bool = False) -&gt; bool\n</code></pre> <p>Adds a node to the network. The node is added to the nodes DataFrame of the network. The function checks the syntax for the genesymbol to ensure it is correct. If the node is a complex, it is added with the 'Genesymbol' as the complex string and 'Uniprot' as the node. Otherwise, it is added with the 'Genesymbol' as the genesymbol and 'Uniprot' as the uniprot. The 'Type' is set as 'NaN' for all new nodes.</p> <p>Args:     - node: A string representing the node to be added. The node can be represented by either its             Genesymbol or Uniprot identifier.</p> <p>Returns:     - None.</p> Source code in <code>neko/core/network.py</code> <pre><code>@_record_state_operation\ndef add_node(self, node: str, from_sif: bool = False) -&gt; bool:\n    \"\"\"\n    Adds a node to the network. The node is added to the nodes DataFrame of the network. The function checks the\n    syntax for the genesymbol to ensure it is correct. If the node is a complex, it is added with the\n    'Genesymbol' as the complex string and 'Uniprot' as the node. Otherwise, it is added with the 'Genesymbol' as\n    the genesymbol and 'Uniprot' as the uniprot. The 'Type' is set as 'NaN' for all new nodes.\n\n    Args:\n        - node: A string representing the node to be added. The node can be represented by either its\n                Genesymbol or Uniprot identifier.\n\n    Returns:\n        - None.\n    \"\"\"\n\n    if from_sif:\n        # check that the new entry node can be translated using the function mapping node identifier (all the\n        # output of the function should be None) if it cannot be translated, print an error message but add the\n        # node to the network anyway\n\n        complex_string, genesymbol, uniprot = mapping_node_identifier(node)\n        if not complex_string and not genesymbol and not uniprot:\n            print(\"Error: node %s could not be automatically translated\" % node)\n            new_entry = {\"Genesymbol\": node, \"Uniprot\": node, \"Type\": \"NaN\"}\n            self.nodes.loc[len(self.nodes)] = new_entry\n            self.nodes = self.nodes.drop_duplicates().reset_index(drop=True)\n            self._add_node_obj(node, node, \"NaN\")\n            return True\n        new_entry = {\"Genesymbol\": genesymbol, \"Uniprot\": uniprot, \"Type\": \"NaN\"}\n        self.nodes.loc[len(self.nodes)] = new_entry\n        self.nodes = self.nodes.drop_duplicates().reset_index(drop=True)\n        self._add_node_obj(genesymbol, uniprot, \"NaN\")\n        self.initial_nodes.append(new_entry[\"Genesymbol\"])\n        self.initial_nodes = list(set(self.initial_nodes))\n        return True\n    complex_string, genesymbol, uniprot = mapping_node_identifier(node)\n    if complex_string:\n        new_entry = {\"Genesymbol\": complex_string, \"Uniprot\": node, \"Type\": \"NaN\"}\n    else:\n        new_entry = {\"Genesymbol\": genesymbol, \"Uniprot\": uniprot, \"Type\": \"NaN\"}\n    if not self.check_node(uniprot) and not self.check_node(genesymbol):\n        print(\"Error: node %s is not present in the resources database\" % node)\n        return False\n    self.nodes.loc[len(self.nodes)] = new_entry\n    self.nodes = self.nodes.drop_duplicates().reset_index(drop=True)\n    self._add_node_obj(new_entry[\"Genesymbol\"], new_entry[\"Uniprot\"], new_entry[\"Type\"])\n    return True\n</code></pre>"},{"location":"api/network/#neko.core.network.Network.add_edge","title":"add_edge","text":"<pre><code>add_edge(edge: DataFrame) -&gt; None\n</code></pre> <p>This method adds an interaction to the list of interactions while converting it to the NeKo-network format. It checks if the edge represents inhibition or stimulation and sets the effect accordingly. It also checks if the nodes involved in the interaction are already present in the network, if not, it adds them.</p> <p>Args:     - edge: A pandas DataFrame representing the interaction. The DataFrame should contain columns for     'source', 'target', 'type', and 'references'. The 'source' and 'target' columns represent the nodes involved     in the interaction. The 'type' column represents the type of interaction. The 'references' column contains     the references for the interaction.</p> <p>Returns:     - None</p> Source code in <code>neko/core/network.py</code> <pre><code>@_record_state_operation\ndef add_edge(self, edge: pd.DataFrame) -&gt; None:\n    \"\"\"\n    This method adds an interaction to the list of interactions while converting it to the NeKo-network format.\n    It checks if the edge represents inhibition or stimulation and sets the effect accordingly. It also checks if the\n    nodes involved in the interaction are already present in the network, if not, it adds them.\n\n    Args:\n        - edge: A pandas DataFrame representing the interaction. The DataFrame should contain columns for\n        'source', 'target', 'type', and 'references'. The 'source' and 'target' columns represent the nodes involved\n        in the interaction. The 'type' column represents the type of interaction. The 'references' column contains\n        the references for the interaction.\n\n    Returns:\n        - None\n    \"\"\"\n\n    # Check if the edge represents inhibition or stimulation and set the effect accordingly\n    effect = check_sign(edge)\n    references = edge[\"references\"].values[0] if \"references\" in edge.columns else None\n    edge_type = edge[\"type\"].values[0] if \"type\" in edge.columns else None\n    df_edge = pd.DataFrame({\n        \"source\": edge[\"source\"],\n        \"target\": edge[\"target\"],\n        \"Type\": edge_type,\n        \"Effect\": effect,\n        \"References\": references\n    })\n\n    # Convert the \"Uniprot\" column to a set for efficient membership test\n    uniprot_nodes = set(self.nodes[\"Uniprot\"].unique())\n\n    # add the new nodes to the nodes dataframe\n    if edge[\"source\"].values[0] not in uniprot_nodes:\n        self.add_node(edge[\"source\"].values[0])\n    if edge[\"target\"].values[0] not in uniprot_nodes:\n        self.add_node(edge[\"target\"].values[0])\n\n    # if in the edge dataframe there is an edge with the same source, target and effect, merge the references\n    existing_edge = self.edges[(self.edges[\"source\"] == edge[\"source\"].values[0]) &amp;\n                               (self.edges[\"target\"] == edge[\"target\"].values[0]) &amp;\n                               (self.edges[\"Effect\"] == effect)]\n    if not existing_edge.empty and references is not None:\n        self.edges.loc[existing_edge.index, \"References\"] += \"; \" + str(references)\n    else:\n        # Concatenate the new edge DataFrame with the existing edges in the graph\n        self.edges = pd.concat([self.edges, df_edge])\n\n    self.edges = self.edges.drop_duplicates().reset_index(drop=True)\n    return\n</code></pre>"},{"location":"api/network/#neko.core.network.Network.remove_node","title":"remove_node","text":"<pre><code>remove_node(node: str) -&gt; None\n</code></pre> <p>Removes a node from the network. The node is removed from both the list of nodes and the list of edges.</p> <p>Args:     - node: A string representing the node to be removed. The node can be represented by either its             Genesymbol or Uniprot identifier.</p> <p>Returns:     - None</p> Source code in <code>neko/core/network.py</code> <pre><code>@_record_state_operation\ndef remove_node(self, node: str) -&gt; None:\n    \"\"\"\n    Removes a node from the network. The node is removed from both the list of nodes and the list of edges.\n\n    Args:\n        - node: A string representing the node to be removed. The node can be represented by either its\n                Genesymbol or Uniprot identifier.\n\n    Returns:\n        - None\n    \"\"\"\n    # Remove the node from the nodes DataFrame\n    self.nodes = self.nodes[(self.nodes.Genesymbol != node) &amp; (self.nodes.Uniprot != node)]\n\n    # Translate the node identifier to Uniprot\n    node = mapping_node_identifier(node)[2]\n\n    # Remove any edges associated with the node from the edges DataFrame\n    self.edges = self.edges[~self.edges[['source', 'target']].isin([node]).any(axis=1)]\n\n    return\n</code></pre>"},{"location":"api/network/#neko.core.network.Network.connect_nodes","title":"connect_nodes","text":"<pre><code>connect_nodes(only_signed: bool = False, consensus_only: bool = False) -&gt; None\n</code></pre> <p>Delegates to strategies.connect_nodes.</p> Source code in <code>neko/core/network.py</code> <pre><code>@_record_state_operation\ndef connect_nodes(self, only_signed: bool = False, consensus_only: bool = False) -&gt; None:\n    \"\"\"\n    Delegates to strategies.connect_nodes.\n    \"\"\"\n    from .strategies import connect_nodes\n    return connect_nodes(self, only_signed=only_signed, consensus_only=consensus_only)\n</code></pre>"},{"location":"api/network/#neko.core.network.Network.connect_subgroup","title":"connect_subgroup","text":"<pre><code>connect_subgroup(group, maxlen: int = 1, only_signed: bool = False, consensus: bool = False) -&gt; None\n</code></pre> <p>Delegates to strategies.connect_subgroup.</p> Source code in <code>neko/core/network.py</code> <pre><code>@_record_state_operation\ndef connect_subgroup(self, group, maxlen: int = 1, only_signed: bool = False, consensus: bool = False) -&gt; None:\n    \"\"\"\n    Delegates to strategies.connect_subgroup.\n    \"\"\"\n    from .strategies import connect_subgroup\n    return connect_subgroup(self, group, maxlen=maxlen, only_signed=only_signed, consensus=consensus)\n</code></pre>"},{"location":"api/network/#neko.core.network.Network.connect_component","title":"connect_component","text":"<pre><code>connect_component(comp_A, comp_B, maxlen: int = 2, mode: Literal['OUT', 'IN', 'ALL'] = 'OUT', only_signed: bool = False, consensus: bool = False) -&gt; None\n</code></pre> <p>Delegates to strategies.connect_component.</p> Source code in <code>neko/core/network.py</code> <pre><code>@_record_state_operation\ndef connect_component(self, comp_A, comp_B, maxlen: int = 2, mode: Literal['OUT', 'IN', 'ALL'] = 'OUT', only_signed: bool = False, consensus: bool = False) -&gt; None:\n    \"\"\"\n    Delegates to strategies.connect_component.\n    \"\"\"\n    from .strategies import connect_component\n    return connect_component(self, comp_A, comp_B, maxlen=maxlen, mode=mode, only_signed=only_signed, consensus=consensus)\n</code></pre>"},{"location":"api/network/#neko.core.network.Network.connect_to_upstream_nodes","title":"connect_to_upstream_nodes","text":"<pre><code>connect_to_upstream_nodes(nodes_to_connect=None, depth: int = 1, rank: int = 1, only_signed: bool = True, consensus: bool = False) -&gt; None\n</code></pre> <p>Delegates to strategies.connect_to_upstream_nodes.</p> Source code in <code>neko/core/network.py</code> <pre><code>@_record_state_operation\ndef connect_to_upstream_nodes(self, nodes_to_connect=None, depth: int = 1, rank: int = 1, only_signed: bool = True, consensus: bool = False) -&gt; None:\n    \"\"\"\n    Delegates to strategies.connect_to_upstream_nodes.\n    \"\"\"\n    from .strategies import connect_to_upstream_nodes\n    return connect_to_upstream_nodes(self, nodes_to_connect=nodes_to_connect, depth=depth, rank=rank, only_signed=only_signed, consensus=consensus)\n</code></pre>"},{"location":"api/network/#neko.core.network.Network.connect_genes_to_phenotype","title":"connect_genes_to_phenotype","text":"<pre><code>connect_genes_to_phenotype(phenotype: str = None, id_accession: str = None, sub_genes: list = None, maxlen: int = 2, only_signed: bool = False, compress: bool = False) -&gt; None\n</code></pre> <p>Delegates to strategies.connect_genes_to_phenotype.</p> Source code in <code>neko/core/network.py</code> <pre><code>@_record_state_operation\ndef connect_genes_to_phenotype(self, phenotype: str = None, id_accession: str = None, sub_genes: list = None, maxlen: int = 2, only_signed: bool = False, compress: bool = False) -&gt; None:\n    \"\"\"\n    Delegates to strategies.connect_genes_to_phenotype.\n    \"\"\"\n    from .strategies import connect_genes_to_phenotype\n    return connect_genes_to_phenotype(self, phenotype=phenotype, id_accession=id_accession, sub_genes=sub_genes, maxlen=maxlen, only_signed=only_signed, compress=compress)\n</code></pre>"},{"location":"api/network/#neko.core.network.Network.complete_connection","title":"complete_connection","text":"<pre><code>complete_connection(maxlen: Optional[int] = 2, algorithm: Literal['bfs', 'dfs'] = 'dfs', minimal: bool = True, only_signed: bool = False, consensus: bool = False, connect_with_bias: bool = False) -&gt; None\n</code></pre> <p>Delegates to strategies.complete_connection.</p> Source code in <code>neko/core/network.py</code> <pre><code>@_record_state_operation\ndef complete_connection(self,\n                    maxlen: Optional[int] = 2,\n                    algorithm: Literal['bfs', 'dfs'] = 'dfs',\n                    minimal: bool = True,\n                    only_signed: bool = False,\n                    consensus: bool = False,\n                        connect_with_bias: bool = False,\n                        ) -&gt; None:\n    \"\"\"\n    Delegates to strategies.complete_connection.\n    \"\"\"\n    from .strategies import complete_connection\n    return complete_connection(self, maxlen=maxlen, algorithm=algorithm, minimal=minimal, only_signed=only_signed, consensus=consensus, connect_with_bias=connect_with_bias)\n</code></pre>"},{"location":"api/network/#neko.core.network.Network.convert_edgelist_into_genesymbol","title":"convert_edgelist_into_genesymbol","text":"<pre><code>convert_edgelist_into_genesymbol() -&gt; pd.DataFrame\n</code></pre> <p>This function generates a new edges dataframe with the source and target identifiers translated (if possible) in Genesymbol format.</p> <p>Args:      - None</p> <p>Returns:     - A pandas DataFrame containing the edges with the source and target identifiers translated into Genesymbol         format.</p> Source code in <code>neko/core/network.py</code> <pre><code>def convert_edgelist_into_genesymbol(self) -&gt; pd.DataFrame:\n    \"\"\"\n    This function generates a new edges dataframe with the source and target identifiers translated (if possible)\n    in Genesymbol format.\n\n    Args:\n         - None\n\n    Returns:\n        - A pandas DataFrame containing the edges with the source and target identifiers translated into Genesymbol\n            format.\n    \"\"\"\n\n    def convert_identifier(x):\n        identifiers = mapping_node_identifier(x)\n        return identifiers[0] or identifiers[1]\n\n    gs_edges = self.edges.copy()\n\n    gs_edges[\"source\"] = gs_edges[\"source\"].apply(convert_identifier)\n    gs_edges[\"target\"] = gs_edges[\"target\"].apply(convert_identifier)\n\n    return gs_edges\n</code></pre>"},{"location":"api/ontology/","title":"Ontology","text":"<p>The <code>Ontology</code> class provides Gene Ontology (GO) utilities: fetching gene sets from GO accessions and mapping phenotypic categories to network nodes.</p>"},{"location":"api/ontology/#import","title":"Import","text":"<pre><code>from neko._annotations.gene_ontology import Ontology\n</code></pre>"},{"location":"api/ontology/#quick-example","title":"Quick example","text":"<pre><code>from neko._annotations.gene_ontology import Ontology\n\nonto = Ontology()\n\n# Fetch all genes annotated to a specific GO term\ngenes = onto.fetch_genes_from_go_id(\"GO:0007165\")  # signal transduction\n\n# Map nodes in a network to tissue expression data\nonto.add_tissue_expression(net, tissue=\"liver\")\n</code></pre>"},{"location":"api/ontology/#helper-function","title":"Helper function","text":""},{"location":"api/ontology/#neko._annotations.gene_ontology.fetch_nodes_from_url","title":"fetch_nodes_from_url","text":"<pre><code>fetch_nodes_from_url(url)\n</code></pre> <p>fetch the nodes in a list from the given geneontology url</p> Source code in <code>neko/_annotations/gene_ontology.py</code> <pre><code>def fetch_nodes_from_url(url):\n\n    \"\"\"\n    fetch the nodes in a list from the given geneontology url\n    \"\"\"\n    print(\"Start requesting genes from Gene Ontology\")\n    print(\"Fetching from: \", url)\n    response = requests.get(url)\n    print(\"Done\")\n    if not response:\n        print(\"Error fetching the genes, no entry found, please check the id accession code\")\n        return\n    genes = response.text.split(\"\\n\")\n    genes = genes[:-1]\n    genes_unique = list(set(genes))\n    return genes_unique\n</code></pre>"},{"location":"api/ontology/#class-reference","title":"Class reference","text":""},{"location":"api/ontology/#neko._annotations.gene_ontology.Ontology","title":"Ontology","text":"<pre><code>Ontology()\n</code></pre> <p>class that stores some functionalities to connect phenotypes to nodes and to associate information for each node at tissue level</p> Source code in <code>neko/_annotations/gene_ontology.py</code> <pre><code>def __init__(self):\n    self.gene_ontology_url = \"https://golr-aux.geneontology.io/solr/select?defType=edismax&amp;qt=standard&amp;indent=on&amp;wt=csv&amp;rows=100000&amp;start=0&amp;fl=bioentity_label&amp;facet=true&amp;facet.mincount=1&amp;facet.sort=count&amp;json.nl=arrarr&amp;facet.limit=25&amp;hl=true&amp;hl.simple.pre=%3Cem%20class=%22hilite%22%3E&amp;hl.snippets=1000&amp;csv.encapsulator=&amp;csv.separator=%09&amp;csv.header=false&amp;csv.mv.separator=%7C&amp;fq=document_category:%22annotation%22&amp;fq=isa_partof_closure:%22GO:0007049%22&amp;fq=taxon_subset_closure_label:%22Homo%20sapiens%22&amp;fq=type:%22protein%22&amp;fq=annotation_class_label:%22G1/S%20transition%20of%20mitotic%20cell%20cycle%22&amp;facet.field=aspect&amp;facet.field=taxon_subset_closure_label&amp;facet.field=type&amp;facet.field=evidence_subset_closure_label&amp;facet.field=regulates_closure_label&amp;facet.field=isa_partof_closure_label&amp;facet.field=annotation_class_label&amp;facet.field=qualifier&amp;facet.field=annotation_extension_class_closure_label&amp;facet.field=assigned_by&amp;facet.field=panther_family_label&amp;q=*:*\"\n    self.accession_to_phenotype_dict = {\"GO:0010718\": \"positive regulation of epithelial to mesenchymal transition\"}\n    return\n</code></pre>"},{"location":"api/ontology/#neko._annotations.gene_ontology.Ontology-functions","title":"Functions","text":""},{"location":"api/ontology/#neko._annotations.gene_ontology.Ontology.modify_url_ontology","title":"modify_url_ontology","text":"<pre><code>modify_url_ontology(new_go_code, new_description)\n</code></pre> <p>Modifies a given URL by replacing a GO code and a descriptive string in very specific locations identified by prefixes.</p> <p>Parameters: - url (str): The original URL to be modified. - new_go_code (str): The new GO code to insert into the URL. - new_description (str): The new descriptive string to insert into the URL.</p> <p>Returns: - str: The modified URL.</p> Source code in <code>neko/_annotations/gene_ontology.py</code> <pre><code>def modify_url_ontology(self, new_go_code, new_description):\n    \"\"\"\n    Modifies a given URL by replacing a GO code and a descriptive string\n    in very specific locations identified by prefixes.\n\n    Parameters:\n    - url (str): The original URL to be modified.\n    - new_go_code (str): The new GO code to insert into the URL.\n    - new_description (str): The new descriptive string to insert into the URL.\n\n    Returns:\n    - str: The modified URL.\n    \"\"\"\n    # Ensure we work with plain strings\n    if not isinstance(new_go_code, str):\n        new_go_code = str(new_go_code)\n    # Define the prefixes that identify where the replacements should occur,\n    go_code_prefix = \"isa_partof_closure:%22\"\n    description_prefix = \"annotation_class_label:%22\"\n\n    # Patterns to find the exact locations for replacements\n    go_code_pattern = re.escape(go_code_prefix) + r\"GO:\\d{7}\"\n    description_pattern = re.escape(description_prefix) + r\".+?%22\"\n\n    # Perform the replacements\n    url = re.sub(go_code_pattern, go_code_prefix + new_go_code, self.gene_ontology_url, 1)\n    # URL-encode the new description\n    new_description_encoded = re.sub(r\" \", \"%20\", new_description)\n    url = re.sub(description_pattern, description_prefix + new_description_encoded + \"%22\", url, 1)\n\n    return url\n</code></pre>"},{"location":"api/ontology/#neko._annotations.gene_ontology.Ontology.check_tissue_annotations","title":"check_tissue_annotations","text":"<pre><code>check_tissue_annotations(genes_df, tissue)\n</code></pre> <p>Check if tissue annotations for each gene symbol contain the specified tissue.</p> <p>Args: genes_df (DataFrame): DataFrame containing gene symbols. tissue (str): Tissue to check for in annotations.</p> <p>Returns: DataFrame: DataFrame with results indicating whether each gene symbol has tissue annotations containing the specified tissue.</p> Source code in <code>neko/_annotations/gene_ontology.py</code> <pre><code>def check_tissue_annotations(self, genes_df, tissue):\n    \"\"\"\n    Check if tissue annotations for each gene symbol contain the specified tissue.\n\n    Args:\n    genes_df (DataFrame): DataFrame containing gene symbols.\n    tissue (str): Tissue to check for in annotations.\n\n    Returns:\n    DataFrame: DataFrame with results indicating whether each gene symbol has tissue annotations containing the specified tissue.\n    \"\"\"\n\n    results = []\n\n    # Iterate over each gene symbol\n    for genesymbol in genes_df['Genesymbol']:\n        # Fetch annotations for the gene symbol\n        annotations_df = op.requests.Annotations.get([genesymbol], force_full_download=True)\n\n        # Filter annotations for tissue annotations\n        tissue_annotations = annotations_df[annotations_df['label'] == 'tissue']\n\n        # Test if any tissue annotation contains the specified tissue\n        in_tissue = any(tissue.lower() in value.lower() for value in tissue_annotations['value'])\n\n        # Append result to list\n        results.append({'Genesymbol': genesymbol, 'in_tissue': in_tissue})\n\n    # Create DataFrame from results\n    results_df = pd.DataFrame(results)\n\n    return results_df\n</code></pre>"},{"location":"api/visualizer/","title":"NetworkVisualizer","text":"<p><code>NetworkVisualizer</code> wraps two rendering backends:</p> <ul> <li>Graphviz \u2013 static PNG/PDF/SVG diagrams via <code>render()</code></li> <li>yFiles \u2013 interactive widget inside Jupyter via <code>yfiles_visual()</code></li> </ul>"},{"location":"api/visualizer/#import","title":"Import","text":"<pre><code>from neko._visual.visualize_network import NetworkVisualizer\n</code></pre>"},{"location":"api/visualizer/#quick-example","title":"Quick example","text":"<pre><code>from neko._visual.visualize_network import NetworkVisualizer\n\nvis = NetworkVisualizer(net, color_by=\"role\")\nvis.set_node_colors({\"EGFR\": \"#e74c3c\"})\nvis.render(\"my_network\", format=\"svg\")\n</code></pre>"},{"location":"api/visualizer/#class-reference","title":"Class reference","text":""},{"location":"api/visualizer/#neko._visual.visualize_network.NetworkVisualizer","title":"NetworkVisualizer","text":"<pre><code>NetworkVisualizer(network, predefined_node=None, color_by='Effect', noi=False)\n</code></pre> <p>Visualize a network using Graphviz and yfiles.</p> <p>Args:     - network (Network): A Network object.     - predefined_node (str): The name of a node to display along with its connections.     - color_by (str): The attribute to use for coloring nodes.     - noi (bool): If True, only display the nodes of interest.</p> <p>Attributes:     - dataframe_edges (DataFrame): DataFrame containing the edges of the network.     - dataframe_nodes (DataFrame): DataFrame containing the nodes of the network.     - initial_nodes (list): List of initial nodes.     - color_by (str): The attribute to use for coloring nodes.     - noi (bool): If True, only display the nodes of interest.     - graph (Digraph): A Digraph object from the Graphviz library.     - edge_colors (dict): Dictionary mapping edge effects to colors.     - node_colors (dict): Dictionary mapping node names to colors.     - predefined_node (str): The name of a node to display along with its connections.</p> <p>Methods:     - set_custom_edge_colors(custom_edge_colors): Set custom edge colors.     - set_node_colors(node_colors): Set custom node colors.     - add_edges_to_graph(): Add edges to the graph.     - add_nodes_to_graph(): Add nodes to the graph.     - tissue_mapping(tissue_df): Color the nodes based on their expression in the tissue of interest.     - render(output_file, view, highlight_nodes, highlight_color): Render the graph.     - yfiles_visual(graph_layout, directed): Visualize the graph using yFiles.     - vis_comparison(int_comparison, node_comparison, graph_layout, directed): Visualize the comparison of two networks.</p> Source code in <code>neko/_visual/visualize_network.py</code> <pre><code>def __init__(self, network, predefined_node=None, color_by=\"Effect\", noi=False):\n    net = network.copy()\n    self.__dataframe_edges = net.convert_edgelist_into_genesymbol().copy()\n    self.__dataframe_nodes = net.nodes\n    self.initial_nodes = net.initial_nodes\n    self.__color_by = color_by\n    self.__noi = noi  # nodes of interest\n    self.graph = Digraph(format='pdf')\n    self.__edge_colors = {\n        'stimulation': 'green',\n        'inhibition': 'red',\n        'form complex': 'blue',\n        'bimodal': 'purple',  # Adding the mapping for \"bimodal\" effect\n        'undefined': 'gray',  # Adding the mapping for \"undefined\" effect\n        # Add more custom mappings if needed\n    }\n    self.__node_colors = {}  # Dictionary to store custom node colors\n    self.predefined_node = wrap_node_name(predefined_node) if predefined_node else None\n    # Apply wrap_node_name function to node names in dataframe_nodes\n    self.__dataframe_nodes['Genesymbol'] = self.__dataframe_nodes['Genesymbol'].apply(wrap_node_name)\n    self.__dataframe_nodes['Uniprot'] = self.__dataframe_nodes['Uniprot'].apply(wrap_node_name)\n\n    # Apply wrap_node_name function to node names in \"source\" and \"target\" columns of dataframe_edges\n    self.__dataframe_edges['source'] = self.__dataframe_edges['source'].apply(wrap_node_name)\n    self.__dataframe_edges['target'] = self.__dataframe_edges['target'].apply(wrap_node_name)\n\n    self.__dataframe_edges = self.__dataframe_edges.drop_duplicates(subset=['source', 'target', 'Type', 'Effect'])\n\n    self.__add_edges_to_graph()\n    self.__add_nodes_to_graph()\n</code></pre>"},{"location":"api/visualizer/#neko._visual.visualize_network.NetworkVisualizer-functions","title":"Functions","text":""},{"location":"api/visualizer/#neko._visual.visualize_network.NetworkVisualizer.set_node_colors","title":"set_node_colors","text":"<pre><code>set_node_colors(node_colors)\n</code></pre> Source code in <code>neko/_visual/visualize_network.py</code> <pre><code>def set_node_colors(self, node_colors):\n    # Update the node_colors dictionary with custom node colorsdataframe_nodes\n    self.__node_colors.update(node_colors)\n</code></pre>"},{"location":"api/visualizer/#neko._visual.visualize_network.NetworkVisualizer.set_custom_edge_colors","title":"set_custom_edge_colors","text":"<pre><code>set_custom_edge_colors(custom_edge_colors)\n</code></pre> Source code in <code>neko/_visual/visualize_network.py</code> <pre><code>def set_custom_edge_colors(self, custom_edge_colors):\n    # Update the edge_colors dictionary with custom mappings\n    self.__edge_colors.update(custom_edge_colors)\n</code></pre>"},{"location":"api/visualizer/#neko._visual.visualize_network.NetworkVisualizer.tissue_mapping","title":"tissue_mapping","text":"<pre><code>tissue_mapping(tissue_df)\n</code></pre> <p>Color the nodes based on their expression in the tissue of interest (based on data from The Human Protein Atlas).</p> <p>Args:     tissue_df (DataFrame): DataFrame containing results indicating whether each gene symbol has tissue annotations containing the selected tissue.</p> Source code in <code>neko/_visual/visualize_network.py</code> <pre><code>def tissue_mapping(self, tissue_df):\n    \"\"\"\n    Color the nodes based on their expression in the tissue of interest (based on data from The Human Protein Atlas).\n\n    Args:\n        tissue_df (DataFrame): DataFrame containing results indicating whether each gene symbol has tissue annotations containing the selected tissue.\n    \"\"\"\n    for _, row in tissue_df.iterrows():\n        gene_symbol = row['Genesymbol']\n        in_tissue = row['in_tissue']\n        node_color = 'lightblue' if in_tissue else 'lightgray'\n        self.__node_colors[gene_symbol] = node_color\n</code></pre>"},{"location":"api/visualizer/#neko._visual.visualize_network.NetworkVisualizer.render","title":"render","text":"<pre><code>render(output_file='network', view=False, highlight_nodes=None, highlight_color='lightyellow')\n</code></pre> <p>Render the graph.</p> <p>Args:     output_file (str): The name of the output file.     view (bool): If True, display the graph.     highlight_nodes (list): List of nodes to highlight.     highlight_color (str): Color to use for highlighting nodes.</p> Source code in <code>neko/_visual/visualize_network.py</code> <pre><code>def render(self, output_file='network', view=False, highlight_nodes=None, highlight_color='lightyellow'):\n    \"\"\"\n    Render the graph.\n\n    Args:\n        output_file (str): The name of the output file.\n        view (bool): If True, display the graph.\n        highlight_nodes (list): List of nodes to highlight.\n        highlight_color (str): Color to use for highlighting nodes.\n    \"\"\"\n    # Apply colors from __node_colors if available\n    if self.__node_colors:\n        for node, color in self.__node_colors.items():\n            if node in self.__dataframe_nodes['Genesymbol'].values:\n                self.graph.node(node, style='filled', fillcolor=color)\n\n    # If highlight_nodes is provided, set the color for each node in the list\n    if highlight_nodes is not None:\n        for node in highlight_nodes:\n            # first check that the node is in the node dataframe\n            if wrap_node_name(node) in self.__dataframe_nodes['Genesymbol'].values:\n                # then change the color only of the node in the graph\n                self.graph.node(wrap_node_name(node), style='filled', fillcolor=highlight_color)\n    if view:\n        self.graph.view(filename=output_file)\n    else:\n        self.graph.render(filename=output_file)\n        display(self.graph)  # Display the graph directly in the Jupyter Notebook\n</code></pre>"},{"location":"api/visualizer/#neko._visual.visualize_network.NetworkVisualizer.yfiles_visual","title":"yfiles_visual","text":"<pre><code>yfiles_visual(graph_layout, directed)\n</code></pre> Source code in <code>neko/_visual/visualize_network.py</code> <pre><code>def yfiles_visual(\n    self,\n    graph_layout,\n    directed,\n):\n    # creating empty object for visualization\n    w = GraphWidget()\n\n    # filling w with nodes\n    objects = []\n    for idx, item in self.__dataframe_nodes.iterrows():\n        obj = {\n            \"id\": self.__dataframe_nodes[\"Uniprot\"].loc[idx],\n            \"properties\": {\"label\": self.__dataframe_nodes[\"Genesymbol\"].loc[idx]},\n            \"color\": \"#ffffff\",\n            \"styles\": {\"backgroundColor\": \"#ffffff\"}\n        }\n        objects.append(obj)\n    w.nodes = objects\n\n    # filling w with edges\n    objects = []\n    for index, row in self.__dataframe_edges.iterrows():\n        obj = {\n            \"id\": self.__dataframe_edges[\"Effect\"].loc[index],\n            \"start\": self.__dataframe_edges[\"source\"].loc[index],\n            \"end\": self.__dataframe_edges[\"target\"].loc[index],\n            \"properties\": {\"references\": self.__dataframe_edges[\"References\"].loc[index]}}\n        objects.append(obj)\n    w.edges = objects\n\n    def custom_edge_color_mapping(edge: Dict):\n        \"\"\"let the edge be red if the interaction is an inhibition, else green\"\"\"\n        return \"#fa1505\" if edge['id'] == \"inhibition\" else \"#05e60c\"\n\n    w.set_edge_color_mapping(custom_edge_color_mapping)\n\n    def custom_node_color_mapping(node: Dict):\n        return {\"color\": \"#ffffff\"}\n\n    w.set_node_styles_mapping(custom_node_color_mapping)\n\n    def custom_factor_mapping(node: Dict):\n        \"\"\"choose random factor\"\"\"\n        return 5\n\n    w.set_node_scale_factor_mapping(custom_factor_mapping)\n\n    def custom_label_styles_mapping(node: Dict):\n        \"\"\"let the label be the negated purple big index\"\"\"\n        return {\n            'text': node[\"properties\"][\"label\"],\n            'backgroundColor': None,\n            'fontSize': 40,\n            'color': '#030200',\n            'shape': 'round-rectangle',\n            'textAlignment': 'center'\n        }\n\n    w.set_node_label_mapping(custom_label_styles_mapping)\n\n    w.directed = directed\n    w.graph_layout = graph_layout\n\n    display(w)\n</code></pre>"},{"location":"api/visualizer/#neko._visual.visualize_network.NetworkVisualizer.vis_comparison","title":"vis_comparison","text":"<pre><code>vis_comparison(int_comparison, node_comparison, graph_layout, directed)\n</code></pre> Source code in <code>neko/_visual/visualize_network.py</code> <pre><code>def vis_comparison(\n    self,\n    int_comparison,\n    node_comparison,\n    graph_layout,\n    directed,\n):\n    # creating empty object for visualization\n    w = GraphWidget()\n\n    objects = []\n    for idx, item in node_comparison.iterrows():\n        obj = {\n            \"id\": node_comparison[\"node\"].loc[idx],\n            \"properties\": {\"label\": node_comparison[\"node\"].loc[idx],\n                           \"comparison\": node_comparison[\"comparison\"].loc[idx], },\n            \"color\": \"#ffffff\",\n            #       \"styles\":{\"backgroundColor\":\"#ffffff\"}\n        }\n        objects.append(obj)\n    w.nodes = objects\n\n    # filling w with edges\n    objects = []\n    for index, row in int_comparison.iterrows():\n        obj = {\n            \"id\": int_comparison[\"comparison\"].loc[index],\n            \"properties\": {\n                \"comparison\": int_comparison[\"comparison\"].loc[index]},\n            \"start\": int_comparison[\"source\"].loc[index],\n            \"end\": int_comparison[\"target\"].loc[index]\n        }\n        objects.append(obj)\n    w.edges = objects\n\n    def custom_node_color_mapping(node: Dict):\n        if node['properties']['comparison'] == \"Unique to Network 1\":\n            return {\"color\": \"#f5f536\"}\n        elif node['properties']['comparison'] == \"Unique to Network 2\":\n            return {\"color\": \"#36f55f\"}\n        elif node['properties']['comparison'] == \"Common\":\n            return {\"color\": \"#3643f5\"}\n\n    w.set_node_styles_mapping(custom_node_color_mapping)\n\n    def custom_factor_mapping(node: Dict):\n        \"\"\"choose random factor\"\"\"\n        return 5\n\n    w.set_node_scale_factor_mapping(custom_factor_mapping)\n\n    def custom_label_styles_mapping(node: Dict):\n        \"\"\"let the label be the negated purple big index\"\"\"\n        return {\n            'text': node[\"id\"],\n            'backgroundColor': None,\n            'fontSize': 20,\n            'color': '#030200',\n            'position': 'center',\n            'maximumWidth': 130,\n            'wrapping': 'word',\n            'textAlignment': 'center'\n        }\n\n    w.set_node_label_mapping(custom_label_styles_mapping)\n\n    def custom_edge_color_mapping(edge: Dict):\n        if edge['id'] == \"Unique to Network 1\":\n            return \"#e3941e\"\n        elif edge['id'] == \"Unique to Network 2\":\n            return \"#36f55f\"\n        elif edge['id'] == \"Common\":\n            return \"#3643f5\"\n        elif edge['id'] == \"Conflicting\":\n            return \"#ffcc00\"\n\n    w.set_edge_color_mapping(custom_edge_color_mapping)\n\n    w.directed = directed\n    w.graph_layout = graph_layout\n\n    display(w)\n</code></pre>"},{"location":"tutorials/","title":"Tutorials","text":"<p>The tutorials below are Jupyter notebooks that walk you through every major NeKo feature, from building your first network to comparing two signalling models.</p> # Notebook Topics covered 1 Network Building Create a <code>Network</code>, load resources, <code>connect_nodes</code> 2 Add Resources Extend the interaction universe with custom databases 3 Stepwise Connection Fine-grained connection strategies 4 Connect Upstream Link upstream regulators to a seed node set 5 Phosphosite Network Build a kinase\u2013substrate network from PhosphoSitePlus 6 Ontology Map nodes to Gene Ontology terms and phenotypes 7 Tissue Mapping Filter interactions by tissue expression 8 Compare Networks Diff two networks and highlight differences 9 Recreating Famous Pathways Reproduce well-known signalling diagrams 10 Import &amp; Complete a Network Import from SIF / GraphML and fill gaps 11 Network History Snapshot, branch, and diff network states"},{"location":"tutorials/#running-the-notebooks-locally","title":"Running the notebooks locally","text":"<pre><code>git clone https://github.com/sysbio-curie/Neko.git\ncd Neko\npip install nekomata\njupyter lab notebooks/\n</code></pre> <p>Note</p> <p>Notebooks that download data (e.g., from OmniPath) require internet access and might take a minute on first run while the database is cached locally.</p>"},{"location":"tutorials/10_Import_and_complete_a_network/","title":"Build, manipulate, export and import networks","text":"<p>This notebook provides the code to create a network, manipulate it, complete it, visualize it, export it to a file (.sif) and import it from a file (.sif).</p> In\u00a0[1]: Copied! <pre>from neko.core.network import Network\nfrom neko._visual.visualize_network import NetworkVisualizer\nfrom neko._outputs.exports import Exports\n</pre> from neko.core.network import Network from neko._visual.visualize_network import NetworkVisualizer from neko._outputs.exports import Exports <pre>(CORNETO) Oct 28 05:36:25 PM - WARNING : No backend found. You can install one of the supported backend by `pip install cvxpy` or `pip install picos`.\n</pre> In\u00a0[2]: Copied! <pre>genes = [\"FAK\", \"NOTCH1\", \"CDH1\", \"CDH2\", \"VIM\", \"MAP4K4\", \"LATS1\", \"LATS2\"]\n</pre> genes = [\"FAK\", \"NOTCH1\", \"CDH1\", \"CDH2\", \"VIM\", \"MAP4K4\", \"LATS1\", \"LATS2\"] In\u00a0[3]: Copied! <pre>new_net1 = Network(genes, resources='omnipath')\n</pre> new_net1 = Network(genes, resources='omnipath') In\u00a0[4]: Copied! <pre>new_net1.complete_connection(algorithm='bfs', only_signed=True, connect_with_bias=True)\n</pre> new_net1.complete_connection(algorithm='bfs', only_signed=True, connect_with_bias=True) <p>In the previous cell, we have built a network from the genes we are interested in. We have used the OmniPath database to retrieve the interactions. We have then completed the network using a breadth-first search algorithm, considering only signed interactions. The option <code>connect_with_bias</code> allows us to connect the nodes prioritizing already existing interactions in the network, over new ones. This means that the resulting network will have a higher density of interactions between the nodes that were already connected. Moreover, our implementation of the bsf algorithm contains a random component, so the resulting network may vary each time you run the code.</p> In\u00a0[5]: Copied! <pre>visualizer1 = NetworkVisualizer(new_net1, color_by='effect')\nvisualizer1.render()\n</pre> visualizer1 = NetworkVisualizer(new_net1, color_by='effect') visualizer1.render() <p>We can remove a node from the network using the method <code>remove_node</code> from the Network object. When a Node is removed, all the edges connected to it are also removed.</p> In\u00a0[6]: Copied! <pre>new_net1.remove_node(\"SRC\")\n</pre> new_net1.remove_node(\"SRC\") In\u00a0[7]: Copied! <pre>visualizer1 = NetworkVisualizer(new_net1, color_by='effect')\nvisualizer1.render()\n</pre> visualizer1 = NetworkVisualizer(new_net1, color_by='effect') visualizer1.render() <p>We can export the network to a file using the method <code>export_sif</code> from the Exports object. The file will be saved in the current directory. The Exports object requires a Network object as input, and it allows us to export the network to different formats, including Bnet.</p> In\u00a0[8]: Copied! <pre>exporter = Exports(new_net1)\n</pre> exporter = Exports(new_net1) In\u00a0[9]: Copied! <pre>exporter.export_sif(\"simple_interaction_format.sif\")\n</pre> exporter.export_sif(\"simple_interaction_format.sif\") <p>We can import a network from a file using the method <code>Network</code> from the Network object. The file must be in SIF format. The Network object requires the path to the file as input.</p> In\u00a0[10]: Copied! <pre>new_net2 = Network(sif_file=\"simple_interaction_format.sif\", resources='omnipath')\n</pre> new_net2 = Network(sif_file=\"simple_interaction_format.sif\", resources='omnipath') In\u00a0[11]: Copied! <pre>visualizer2 = NetworkVisualizer(new_net2, color_by='effect')\nvisualizer2.render()\n</pre> visualizer2 = NetworkVisualizer(new_net2, color_by='effect') visualizer2.render() <p>Just for demonstration purposes, we can add a node to the network using the method <code>add_node</code> from the Network object. The node can be connected later to the rest of the network using the same or different algorithms.</p> In\u00a0[12]: Copied! <pre>new_net2.add_node(\"SRC\")\n</pre> new_net2.add_node(\"SRC\") In\u00a0[13]: Copied! <pre>new_net2.nodes\n</pre> new_net2.nodes Out[13]: Genesymbol Uniprot Type 0 EPHA2 P29317 NaN 1 COMPLEX:P06493_P14635 COMPLEX:P06493_P14635 NaN 2 LATS1 O95835 NaN 3 PLK1 P53350 NaN 4 GADD45A P24522 NaN 5 CDH1 P12830 NaN 6 CDK1 P06493 NaN 7 INCENP Q9NQS7 NaN 8 LATS2 Q9NRM7 NaN 9 MAP3K1 Q13233 NaN 10 PTK2 Q05397 NaN 11 MAP3K7 O43318 NaN 12 NF2 P35240 NaN 13 GSK3B P49841 NaN 14 PRKCA P17252 NaN 15 CDH2 P19022 NaN 16 VIM P08670 NaN 17 FLT4 P35916 NaN 18 MAP4K4 O95819 NaN 19 RAP1A P62834 NaN 20 FOS P01100 NaN 21 CDC42 P60953 NaN 22 ITGB1 P05556 NaN 23 PTPN1 P18031 NaN 24 INSR P06213 NaN 25 TP53 P04637 NaN 26 NOTCH1 P46531 NaN 27 SRC P12931 NaN In\u00a0[14]: Copied! <pre>visualizer2 = NetworkVisualizer(new_net2, color_by='effect')\nvisualizer2.render()\n</pre> visualizer2 = NetworkVisualizer(new_net2, color_by='effect') visualizer2.render() <p>We can now complete the network and connect the disconnected node that we have previously added. Moreover, by choosing a different algorithm, we can obtain a different network structure, and get interactions that we have not considered before.</p> In\u00a0[15]: Copied! <pre>new_net2.complete_connection(maxlen=2, algorithm='dfs', only_signed=True)\n</pre> new_net2.complete_connection(maxlen=2, algorithm='dfs', only_signed=True) In\u00a0[16]: Copied! <pre>visualizer2 = NetworkVisualizer(new_net2, color_by='effect')\nvisualizer2.render()\n</pre> visualizer2 = NetworkVisualizer(new_net2, color_by='effect') visualizer2.render() In\u00a0[17]: Copied! <pre>new_net2.edges\n</pre> new_net2.edges Out[17]: source target Type Effect References 0 P46531 P35916 None stimulation SIF file; nan 1 P35916 Q05397 None stimulation SIF file; HPRD:16452200 2 P49841 P46531 None stimulation SIF file; ACSN:11967263;ACSN:14663202;ACSN:150... 3 P49841 P12830 None stimulation SIF file; ACSN:10671551;ACSN:10671552;ACSN:112... 4 P12830 P29317 None stimulation SIF file; nan ... ... ... ... ... ... 187 P29353 P62993 None stimulation Adhesome:10049786;Adhesome:10080542;Adhesome:1... 188 P62993 P29353 None stimulation Adhesome:10049786;Adhesome:10080542;Adhesome:1... 189 P62993 P19174 None stimulation Adhesome:10940929;Adhesome:15953601;Adhesome:7... 190 P19174 P17612 None bimodal Adhesome:2479646 191 P17612 P19174 None inhibition Adhesome:2479646;CA1:2479646;ProtMapper:137047... <p>192 rows \u00d7 5 columns</p> <p>As we can see the Network contains bimodal interactions. We can remove them from the network if we consider that they are not relevant for our analysis.</p> In\u00a0[18]: Copied! <pre>new_net2.edges[new_net2.edges[\"Effect\"] == \"bimodal\"]\n</pre> new_net2.edges[new_net2.edges[\"Effect\"] == \"bimodal\"] Out[18]: source target Type Effect References 16 P17252 P08670 None bimodal SIF file; Adhesome:2500966;HPRD-phos:11895474;... 22 P18031 P06213 None bimodal SIF file; Adhesome:10592173;Adhesome:10751417;... 23 P06213 P18031 None bimodal SIF file; Adhesome:10592173;Adhesome:10751417;... 38 P49841 P04637 None bimodal SIF file; ELM:11483158;HPRD-phos:11483158;HPRD... 50 P06493 P08670 None bimodal SIF file; HPRD-phos:15345747;HPRD-phos:1656522... 74 P12931 P29317 None bimodal ProtMapper:24457997;ProtMapper:26788993;ProtMa... 91 P17612 P35240 None bimodal KEA:15378014;KEA:18071304;PhosphoSite:11703924... 110 P17612 P49841 None bimodal HPRD-phos:12054501;HPRD-phos:18669648;HPRD-pho... 111 P17252 P12931 None bimodal ACSN:11313945;ACSN:11447289;ACSN:11940581;ACSN... 118 P17252 P19174 None bimodal Adhesome:10592173;Adhesome:1370476;Adhesome:28... 132 P17612 P62834 None bimodal CA1:8463283;CA1:9867809;HPRD-phos:9867809;HPRD... 145 P05556 P29353 None bimodal Adhesome:10964917;Adhesome:19889638;InnateDB:1... 149 P18031 P12931 None bimodal Adhesome:11007774;Adhesome:12857726;Adhesome:1... 162 P12931 P61586 None bimodal Adhesome:10592173;SIGNOR:23027962 163 P12931 P20936 None bimodal Adhesome:11389730;Adhesome:1717825;BioGRID:171... 170 P63000 P61586 None bimodal Adhesome:10592173 181 P56945 P61586 None bimodal NaN 183 P17612 P61586 None bimodal Adhesome:12654918;Adhesome:8599934;HPRD-phos:1... 190 P19174 P17612 None bimodal Adhesome:2479646 In\u00a0[19]: Copied! <pre>import pandas as pd\n</pre> import pandas as pd In\u00a0[20]: Copied! <pre># remove from the Network object all the interaction that are bimodal with less than X references (each reference is separated by ;)\n\nnumber_of_references = 55\n\nfor index, row in new_net2.edges[new_net2.edges[\"Effect\"] == \"bimodal\"].iterrows():\n    if pd.isna(row[\"References\"]) or len(row[\"References\"].split(\";\")) &lt; number_of_references: \n        print(\"Removing edge between\", row[\"source\"], \"and\", row[\"target\"])\n        new_net2.remove_edge(row[\"source\"], row[\"target\"])\n</pre> # remove from the Network object all the interaction that are bimodal with less than X references (each reference is separated by ;)  number_of_references = 55  for index, row in new_net2.edges[new_net2.edges[\"Effect\"] == \"bimodal\"].iterrows():     if pd.isna(row[\"References\"]) or len(row[\"References\"].split(\";\")) &lt; number_of_references:          print(\"Removing edge between\", row[\"source\"], \"and\", row[\"target\"])         new_net2.remove_edge(row[\"source\"], row[\"target\"]) <pre>Removing edge between P17252 and P08670\nRemoving edge between P49841 and P04637\nRemoving edge between P12931 and P29317\nRemoving edge between P17612 and P35240\nRemoving edge between P17612 and P49841\nRemoving edge between P17252 and P12931\nRemoving edge between P17252 and P19174\nRemoving edge between P17612 and P62834\nRemoving edge between P05556 and P29353\nRemoving edge between P18031 and P12931\nRemoving edge between P12931 and P61586\nRemoving edge between P12931 and P20936\nRemoving edge between P63000 and P61586\nRemoving edge between P56945 and P61586\nRemoving edge between P17612 and P61586\nRemoving edge between P19174 and P17612\n</pre> In\u00a0[21]: Copied! <pre>new_net2.edges[new_net2.edges[\"Effect\"] == \"bimodal\"]\n</pre> new_net2.edges[new_net2.edges[\"Effect\"] == \"bimodal\"] Out[21]: source target Type Effect References 22 P18031 P06213 None bimodal SIF file; Adhesome:10592173;Adhesome:10751417;... 23 P06213 P18031 None bimodal SIF file; Adhesome:10592173;Adhesome:10751417;... 50 P06493 P08670 None bimodal SIF file; HPRD-phos:15345747;HPRD-phos:1656522... In\u00a0[22]: Copied! <pre>visualizer2 = NetworkVisualizer(new_net2, color_by='effect')\nvisualizer2.render()\n</pre> visualizer2 = NetworkVisualizer(new_net2, color_by='effect') visualizer2.render() <p>We can export the network to a file using the method <code>export_bnet</code> from the Exports object. The file will be saved in the current directory. The user must specify the name of the file WITHOUT the extension.  In case the Network contains bimodal interactions, the function will export a file for each possible permutation of the interactions. This number scales exponentially with the number of bimodal interactions in the network, resulting in a large number of files. BE CAREFUL when exporting a network with bimodal interactions!</p> In\u00a0[23]: Copied! <pre>exporter2 = Exports(new_net2)\n</pre> exporter2 = Exports(new_net2) In\u00a0[24]: Copied! <pre>exporter2.export_bnet(\"./logical_models/logical_model\")\n</pre> exporter2.export_bnet(\"./logical_models/logical_model\") <pre>Warning: The network has 3 BIMODAL interaction(s).\nBimodal interactions:\nPTPN1 -&gt; INSR\nReference: SIF file; Adhesome:10592173;Adhesome:10751417;Adhesome:10807907;Adhesome:11163213;Adhesome:11506178;Adhesome:11579209;Adhesome:11726652;Adhesome:12237455;Adhesome:12612081;Adhesome:12634852;Adhesome:14722096;Adhesome:15588987;Adhesome:16271887;Adhesome:16582879;Adhesome:16926280;Adhesome:17092689;Adhesome:17159996;Adhesome:17481567;Adhesome:19029027;Adhesome:21806020;Adhesome:8702689;Adhesome:8999839;CA1:14722096;DEPOD:11163213;DEPOD:11579209;DEPOD:12237455;DEPOD:12634852;DEPOD:14722096;DEPOD:15588987;DEPOD:16271887;DEPOD:16582879;DEPOD:17159996;DEPOD:17481567;DEPOD:8826975;DEPOD:8999839;DIP:16271887;DOMINO:11163213;DOMINO:11579209;DOMINO:12237455;DOMINO:12634852;DOMINO:15588987;DOMINO:16926280;DOMINO:17481567;HPRD-phos:16582879;HPRD:11506178;HPRD:12237455;HPRD:16582879;HPRD:8826975;HPRD:9355745;InnateDB:11579209;InnateDB:12237455;InnateDB:12612081;InnateDB:14722096;InnateDB:17481567;IntAct:11163213;IntAct:11506178;IntAct:11579209;IntAct:12237455;IntAct:12634852;IntAct:14722096;IntAct:15588987;IntAct:16582879;IntAct:16926280;IntAct:17092689;IntAct:17159996;IntAct:17481567;IntAct:19029027;IntAct:21806020;IntAct:8702689;IntAct:8999839;KEA:10852715;KEA:11850117;Lit-BM-17:11163213;Lit-BM-17:11506178;Lit-BM-17:11579209;Lit-BM-17:11726652;Lit-BM-17:12237455;Lit-BM-17:12634852;Lit-BM-17:14722096;Lit-BM-17:15588987;Lit-BM-17:16271887;Lit-BM-17:16582879;Lit-BM-17:16926280;Lit-BM-17:17092689;Lit-BM-17:17159996;Lit-BM-17:17481567;Lit-BM-17:19029027;Lit-BM-17:21806020;Lit-BM-17:8999839;ProtMapper:10066179;ProtMapper:11579209;ProtMapper:12612081;ProtMapper:1321126;ProtMapper:15192089;ProtMapper:15632081;ProtMapper:1599438;ProtMapper:16582879;ProtMapper:8244979;SIGNOR:11579209;SIGNOR:16582879;SPIKE_LC:8999839;SignaLink3:11506178;SignaLink3:12237455;SignaLink3:15632081;SignaLink3:16582879;SignaLink3:23331499;SignaLink3:8826975;SignaLink3:9355745\nINSR -&gt; PTPN1\nReference: SIF file; Adhesome:10592173;Adhesome:10751417;Adhesome:10807907;Adhesome:11163213;Adhesome:11506178;Adhesome:11579209;Adhesome:11726652;Adhesome:12237455;Adhesome:12612081;Adhesome:12634852;Adhesome:14722096;Adhesome:15588987;Adhesome:16271887;Adhesome:16582879;Adhesome:16926280;Adhesome:17092689;Adhesome:17159996;Adhesome:17481567;Adhesome:19029027;Adhesome:21806020;Adhesome:8702689;Adhesome:8999839;DIP:16271887;DOMINO:11163213;DOMINO:11579209;DOMINO:12237455;DOMINO:12634852;DOMINO:15588987;DOMINO:16926280;DOMINO:17481567;HPRD-phos:11506178;HPRD-phos:9355745;HPRD:11506178;HPRD:12237455;HPRD:16582879;HPRD:8826975;HPRD:9355745;InnateDB:11579209;InnateDB:12237455;InnateDB:12612081;InnateDB:14722096;InnateDB:17481567;IntAct:11163213;IntAct:11506178;IntAct:11579209;IntAct:12237455;IntAct:12634852;IntAct:14722096;IntAct:15588987;IntAct:16582879;IntAct:16926280;IntAct:17092689;IntAct:17159996;IntAct:17481567;IntAct:19029027;IntAct:21806020;IntAct:8702689;IntAct:8999839;KEA:11106648;KEA:11506178;KEA:17570479;KEA:8999839;KEA:9355745;Lit-BM-17:11163213;Lit-BM-17:11506178;Lit-BM-17:11579209;Lit-BM-17:11726652;Lit-BM-17:12237455;Lit-BM-17:12634852;Lit-BM-17:14722096;Lit-BM-17:15588987;Lit-BM-17:16271887;Lit-BM-17:16582879;Lit-BM-17:16926280;Lit-BM-17:17092689;Lit-BM-17:17159996;Lit-BM-17:17481567;Lit-BM-17:19029027;Lit-BM-17:21806020;Lit-BM-17:8999839;ProtMapper:11506178;ProtMapper:11579209;ProtMapper:15212693;SIGNOR:11506178;SPIKE_LC:8999839;iPTMnet:11106648;iPTMnet:11506178;iPTMnet:9355745;phosphoELM:11106648\nCDK1 -&gt; VIM\nReference: SIF file; HPRD-phos:15345747;HPRD-phos:16565220;HPRD-phos:16964243;HPRD-phos:17287340;HPRD-phos:17924679;HPRD-phos:18212344;HPRD-phos:18491316;HPRD-phos:18578522;HPRD-phos:18669648;HPRD-phos:18691976;HPRD-phos:18707149;HPRD-phos:18767875;HPRD-phos:19007248;HPRD-phos:19413330;HPRD-phos:19415658;HPRD-phos:19651622;HPRD-phos:19664995;HPRD-phos:19691289;HPRD-phos:20058876;HPRD-phos:20068230;HPRD-phos:20068231;HPRD-phos:7983050;HPRD:15345747;HPRD:7983050;KEA:12761892;KEA:15345747;KEA:15713670;KEA:15766329;KEA:16565220;KEA:16964243;KEA:17081983;KEA:17570479;KEA:7983050;PhosphoSite:19584300;ProtMapper:16260496;ProtMapper:16542212;ProtMapper:21422740;ProtMapper:22120848;ProtMapper:24073199;ProtMapper:25184044;ProtMapper:25960391;ProtMapper:27603133;ProtMapper:7983050;ProtMapper:9168797;SIGNOR:7983050;dbPTM:16565220;dbPTM:16964243;dbPTM:17081983;dbPTM:17287340;dbPTM:17924679;dbPTM:18669648;dbPTM:18691976;dbPTM:19007248;dbPTM:19369195;dbPTM:19413330;dbPTM:19690332;dbPTM:21465480;iPTMnet:15345747;iPTMnet:16260496;iPTMnet:16565220;iPTMnet:16964243;iPTMnet:17287340;iPTMnet:17924679;iPTMnet:18212344;iPTMnet:18491316;iPTMnet:18578522;iPTMnet:18669648;iPTMnet:18691976;iPTMnet:18707149;iPTMnet:18767875;iPTMnet:19007248;iPTMnet:19413330;iPTMnet:19415658;iPTMnet:19651622;iPTMnet:19664995;iPTMnet:19691289;iPTMnet:20058876;iPTMnet:20068230;iPTMnet:20068231;iPTMnet:27603133;iPTMnet:7983050;phosphoELM:7983050\nCreated BNet file: ./logical_models/logical_model_1.bnet\nCreated BNet file: ./logical_models/logical_model_2.bnet\nCreated BNet file: ./logical_models/logical_model_3.bnet\nCreated BNet file: ./logical_models/logical_model_4.bnet\nCreated BNet file: ./logical_models/logical_model_5.bnet\nCreated BNet file: ./logical_models/logical_model_6.bnet\nCreated BNet file: ./logical_models/logical_model_7.bnet\nCreated BNet file: ./logical_models/logical_model_8.bnet\nGenerated 8 BNet files.\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"tutorials/10_Import_and_complete_a_network/#build-manipulate-export-and-import-networks","title":"Build, manipulate, export and import networks\u00b6","text":""},{"location":"tutorials/10_Import_and_complete_a_network/#1-define-a-set-of-genes-we-are-interested-in","title":"1. Define a set of genes we are interested in\u00b6","text":""},{"location":"tutorials/10_Import_and_complete_a_network/#2-build-the-network-from-omnipath","title":"2. Build the network from OmniPath\u00b6","text":""},{"location":"tutorials/10_Import_and_complete_a_network/#3-visualize-the-network","title":"3. Visualize the network\u00b6","text":""},{"location":"tutorials/10_Import_and_complete_a_network/#4-manipulate-the-network-remove-a-node","title":"4. Manipulate the network: remove a node\u00b6","text":""},{"location":"tutorials/10_Import_and_complete_a_network/#5-export-the-network-to-a-sif-file","title":"5. Export the network to a SIF file\u00b6","text":""},{"location":"tutorials/10_Import_and_complete_a_network/#6-import-the-network-from-a-sif-file","title":"6. Import the network from a SIF file\u00b6","text":""},{"location":"tutorials/10_Import_and_complete_a_network/#7-manipulate-the-network-add-a-node","title":"7. Manipulate the network: add a node\u00b6","text":""},{"location":"tutorials/10_Import_and_complete_a_network/#8-manipulate-the-network-complete-the-network","title":"8. Manipulate the network: complete the network\u00b6","text":""},{"location":"tutorials/10_Import_and_complete_a_network/#9-manipulate-the-network-remove-bimodal-interactions","title":"9. Manipulate the network: remove bimodal interactions\u00b6","text":""},{"location":"tutorials/10_Import_and_complete_a_network/#10-export-the-network-to-a-bnet-file","title":"10. Export the network to a Bnet file\u00b6","text":""},{"location":"tutorials/1_network_building/","title":"Usage","text":"In\u00a0[1]: Copied! <pre>%%time\nfrom neko.core.network import Network\nfrom neko._visual.visualize_network import NetworkVisualizer\nimport omnipath as op\n</pre> %%time from neko.core.network import Network from neko._visual.visualize_network import NetworkVisualizer import omnipath as op <pre>CPU times: user 3.58 s, sys: 898 ms, total: 4.48 s\nWall time: 4.48 s\n</pre> In\u00a0[2]: Copied! <pre>genes = [\"SRC\", \"NOTCH1\", \"FAK\", \"CDH1\", \"CDH2\", \"VIM\", \"MAP4K4\", \"LATS1\", \"LATS2\", \"PTK2B\"]\n</pre> genes = [\"SRC\", \"NOTCH1\", \"FAK\", \"CDH1\", \"CDH2\", \"VIM\", \"MAP4K4\", \"LATS1\", \"LATS2\", \"PTK2B\"] In\u00a0[12]: Copied! <pre>new_net1 = Network(genes, resources = 'omnipath')\n</pre> new_net1 = Network(genes, resources = 'omnipath') In\u00a0[13]: Copied! <pre>#Print node dataframe\nnew_net1.nodes\n</pre> #Print node dataframe new_net1.nodes Out[13]: Genesymbol Uniprot Type 0 SRC P12931 NaN 1 NOTCH1 P46531 NaN 2 PTK2 Q05397 NaN 3 CDH1 P12830 NaN 4 CDH2 P19022 NaN 5 VIM P08670 NaN 6 MAP4K4 O95819 NaN 7 LATS1 O95835 NaN 8 LATS2 Q9NRM7 NaN 9 PTK2B Q14289 NaN In\u00a0[14]: Copied! <pre>%%time\nnew_net1.connect_nodes(only_signed=True, consensus_only=True)\n</pre> %%time new_net1.connect_nodes(only_signed=True, consensus_only=True) <pre>CPU times: user 189 ms, sys: 6 \u03bcs, total: 189 ms\nWall time: 188 ms\n</pre> In\u00a0[15]: Copied! <pre>visualizer = NetworkVisualizer(new_net1, color_by='effect', noi=True)\nvisualizer.render()\n</pre> visualizer = NetworkVisualizer(new_net1, color_by='effect', noi=True) visualizer.render() In\u00a0[16]: Copied! <pre>%%time\nnew_net1.complete_connection(maxlen=3, algorithm=\"bfs\", only_signed=True, connect_with_bias=False, consensus=True)\n</pre> %%time new_net1.complete_connection(maxlen=3, algorithm=\"bfs\", only_signed=True, connect_with_bias=False, consensus=True) <pre>CPU times: user 10.5 s, sys: 1.02 ms, total: 10.5 s\nWall time: 10.5 s\n</pre> In\u00a0[18]: Copied! <pre>#Visualize a specific nodes and \nvisualizer1 = NetworkVisualizer(new_net1,color_by='effect', noi=True)\nvisualizer1.render()\n</pre> #Visualize a specific nodes and  visualizer1 = NetworkVisualizer(new_net1,color_by='effect', noi=True) visualizer1.render() In\u00a0[9]: Copied! <pre>#Visualize a specific nodes and \nvisualizer1 = NetworkVisualizer(new_net1, predefined_node = \"SRC\",color_by='effect')\nvisualizer1.render()\n</pre> #Visualize a specific nodes and  visualizer1 = NetworkVisualizer(new_net1, predefined_node = \"SRC\",color_by='effect') visualizer1.render() In\u00a0[17]: Copied! <pre>#We can access to the edges of the network\nnew_net1.edges\n</pre> #We can access to the edges of the network new_net1.edges Out[17]: source target Type Effect References Provenance 0 P12931 Q05397 None stimulation Adhesome:10085298;Adhesome:10592173;Adhesome:1... None 1 P12830 P12931 None stimulation ACSN:16039586;ACSN:16099633;ACSN:17143292;ACSN... None 2 P12931 P19022 None inhibition ACSN:15782139;ACSN:16371504;ACSN:16492141;ACSN... None 3 P12931 Q14289 None stimulation Adhesome:10329689;Adhesome:10521452;Adhesome:1... None 4 Q14289 Q05397 None stimulation Adhesome:16760434;HPRD:16760434;KEA:12960434;K... None ... ... ... ... ... ... ... 221 P01106 O95863 None stimulation NaN None 222 P61586 P42336 None stimulation NaN None 223 P42336 P61586 None stimulation NaN None 224 P05305 P61586 None stimulation NaN None 225 Q13043 O15151 None stimulation NaN None <p>226 rows \u00d7 6 columns</p> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"tutorials/1_network_building/#usage","title":"Usage\u00b6","text":"<p>This notebook provides the steps to build a network starting from a list of genes, and using the default functionalities of NeKo.</p>"},{"location":"tutorials/1_network_building/#1-define-the-list-of-genes-of-interest","title":"1. Define the list of genes of interest\u00b6","text":""},{"location":"tutorials/1_network_building/#2-create-a-network-using-as-input-the-gene-set","title":"2. Create a network using as input the gene set.\u00b6","text":"<p>Note</p> <p>NB! If no resource is specified, the default used resource by the package is <code>omnipath.interactions.Omnipath()</code>. To add new resources, please see the Add resources tutorial.</p>"},{"location":"tutorials/1_network_building/#2a-import-genes-as-network-nodes","title":"2A. Import genes as network nodes\u00b6","text":""},{"location":"tutorials/1_network_building/#2b-explore-if-the-nodes-are-connected-without-introducing-new-intermidiate-nodes","title":"2B. Explore if the nodes are connected without introducing new intermidiate nodes\u00b6","text":""},{"location":"tutorials/1_network_building/#2c-visualize-the-network-with-the-following-command","title":"2C. Visualize the network with the following command.\u00b6","text":"<p>The network picture is also exported in the working repository, in pdf format.</p>"},{"location":"tutorials/1_network_building/#2d-connect-disconnected-nodes-by-importing-intermediate-nodes","title":"2D. Connect disconnected nodes by importing intermediate nodes.\u00b6","text":"<p>The parameter *maxlen* sets the maximum length of the paths to be searched of.</p> <p>The parameter *algorithm* sets the base algorithm to use when looking for paths in the resources. It can be 'bfs' (Breadth-First Search) or 'dfs' (Depth-First Search - iterative). The first one is faster but does not retrieve all the shortest path, just the first one found, while the second one retrieves all the possible shortest paths (but not only the shortest) at higher computational cost.</p> <p>The parameter *only_signed* forces the algorithm to look for just signed interactions.</p> <p>The parameter *consensus* retrieves those interactions with a sign consensus between the references (when possible).</p> <p>The parameter *connect_with_bias*, changes the base algorithm, making it look for possible connection between all the disconnected node in the network when a new bridge-gene is introduced in the network, biasing the final network topology.</p>"},{"location":"tutorials/1_network_building/#3-visualize-final-network","title":"3. Visualize final network\u00b6","text":""},{"location":"tutorials/2_add_resources/","title":"Build network using user-defined resources","text":"In\u00a0[1]: Copied! <pre>%%time\nfrom neko.core.network import Network\nfrom neko._visual.visualize_network import NetworkVisualizer\nfrom neko.inputs import Universe, signor\nimport omnipath as op\nimport pandas as pd\n</pre> %%time from neko.core.network import Network from neko._visual.visualize_network import NetworkVisualizer from neko.inputs import Universe, signor import omnipath as op import pandas as pd <pre>CPU times: user 3.52 s, sys: 833 ms, total: 4.35 s\nWall time: 4.2 s\n</pre> In\u00a0[2]: Copied! <pre>collectri = op.interactions.CollecTRI.get()\n</pre> collectri = op.interactions.CollecTRI.get() In\u00a0[3]: Copied! <pre>resources = Universe()\nresources.add_resources(collectri, name = 'collectri')\nresources.build()\n</pre> resources = Universe() resources.add_resources(collectri, name = 'collectri') resources.build() In\u00a0[\u00a0]: Copied! <pre>resources.interactions # can be used inside a Network object\n</pre> resources.interactions # can be used inside a Network object Out[\u00a0]: source target is_directed is_stimulation is_inhibition consensus_direction consensus_stimulation consensus_inhibition curation_effort references sources n_sources n_primary_sources n_references references_stripped form_complex 0 P01106 O14746 False True False True True False 82 CollecTRI:10022128;CollecTRI:10491298;CollecTR... CollecTRI;DoRothEA-A_CollecTRI;ExTRI_CollecTRI... 8 1 74 10022128;10491298;10606235;10637317;10723141;1... False 1 P17947 P02818 False True False True True False 3 CollecTRI:10022617 CollecTRI;ExTRI_CollecTRI 2 1 1 10022617 False 2 COMPLEX:P15407_P17275 P05412 False True False True True False 53 CollecTRI:10022869;CollecTRI:10037172;CollecTR... CollecTRI;ExTRI_CollecTRI;NTNU.Curated_CollecT... 4 1 49 10022869;10037172;10208431;10366004;11281649;1... False 3 COMPLEX:P01100_P05412 P05412 False True False True True False 53 CollecTRI:10022869;CollecTRI:10037172;CollecTR... CollecTRI;ExTRI_CollecTRI;NTNU.Curated_CollecT... 4 1 49 10022869;10037172;10208431;10366004;11281649;1... False 4 COMPLEX:P01100_P17275 P05412 False True False True True False 53 CollecTRI:10022869;CollecTRI:10037172;CollecTR... CollecTRI;ExTRI_CollecTRI;NTNU.Curated_CollecT... 4 1 49 10022869;10037172;10208431;10366004;11281649;1... False ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... 64490 Q01196 Q13094 False True False True True False 3 CollecTRI:20019798 CollecTRI;DoRothEA-A_CollecTRI 2 1 1 20019798 False 64491 Q01196 Q6MZQ0 False True False True True False 3 CollecTRI:20019798 CollecTRI;DoRothEA-A_CollecTRI 2 1 1 20019798 False 64492 Q15672 P08151 False True False True True False 3 CollecTRI:11948912 CollecTRI;DoRothEA-A_CollecTRI 2 1 1 11948912 False 64493 P22415 Q5SRE5 False True False True True False 3 CollecTRI:22951020 CollecTRI;DoRothEA-A_CollecTRI 2 1 1 22951020 False 64494 Q9UQR1 Q5VYX0 False True False True True False 3 CollecTRI:25295465 CollecTRI;DoRothEA-A_CollecTRI 2 1 1 25295465 False <p>64495 rows \u00d7 16 columns</p> <p>It is important once added a new resource, to build the database as showcases in the previous cell. All those steps assure that the incoming database is compatible with the NeKo structure, possibly avoiding mistakes when running the connecting algorithms.</p> <p>Sometimes a WARNING can suggest that some interactions could be missing; while this is limiting the amount of knowledge NeKo can extract, it does not prevent the package from working. Other possible cause of a WARNING is the absence of \"consensus\" columns. To avoid errors while running the package, set always consensus to False.</p> In\u00a0[5]: Copied! <pre>resources = signor()  # this function accept as argument also a PATH to the signor file\nresources.build()\n</pre> resources = signor()  # this function accept as argument also a PATH to the signor file resources.build() In\u00a0[6]: Copied! <pre>resources.interactions\n</pre> resources.interactions Out[6]: source target is_directed is_stimulation is_inhibition form_complex consensus_direction consensus_stimulation consensus_inhibition curation_effort references sources 0 A0A0B4J2F0 P18848 True False True False False False False miannu 31653868 SIGNOR-261041 1 A0A0B4J2F0 P35638 True False True False False False False miannu 31653868 SIGNOR-261043 2 A0A0B4J2F0 SIGNOR-PH2 True False True False False False False miannu 31653868 SIGNOR-261042 3 A0AVT1 SIGNOR-C496 True False False True False False False miannu 24816100 SIGNOR-270835 4 A0JLT2 SIGNOR-C405 True False False True False False False miannu 28467824 SIGNOR-266663 ... ... ... ... ... ... ... ... ... ... ... ... ... 28783 URS000037EC34_9606 SIGNOR-PH37 True True False False False False False miannu 24708856 SIGNOR-255763 28784 URS000075AE07_9606 SIGNOR-FP4 True False True False False False False irozzo 23132946 SIGNOR-255883 28785 URS000075C517_9606 SIGNOR-PH109 True True False False False False False miannu 26055960 SIGNOR-255801 28786 URS000075C517_9606 SIGNOR-PH2 True True False False False False False Luana 26344767 SIGNOR-264545 28787 URS000075C517_9606 SIGNOR-PH4 True False True False False False False Luana 19219026 SIGNOR-268044 <p>28788 rows \u00d7 12 columns</p> <p>In order to avoid conflict or errors, ensure that the file contains at least the following columns: IDA, IDB, EFFECT, ANNOTATOR, PMID, SIGNOR_ID</p> In\u00a0[7]: Copied! <pre>genes = [\"SRC\", \"NOTCH1\", \"PTK2\", \"CDH1\", \"CDH2\", \"VIM\", \"MAP4K4\", \"LATS1\", \"LATS2\"]\n</pre> genes = [\"SRC\", \"NOTCH1\", \"PTK2\", \"CDH1\", \"CDH2\", \"VIM\", \"MAP4K4\", \"LATS1\", \"LATS2\"] In\u00a0[8]: Copied! <pre>new_net1 = Network(genes, resources = resources.interactions)\n</pre> new_net1 = Network(genes, resources = resources.interactions) In\u00a0[9]: Copied! <pre>#Print node dataframe\nnew_net1.nodes\n</pre> #Print node dataframe new_net1.nodes Out[9]: Genesymbol Uniprot Type 0 SRC P12931 NaN 1 NOTCH1 P46531 NaN 2 PTK2 Q05397 NaN 3 CDH1 P12830 NaN 4 CDH2 P19022 NaN 5 VIM P08670 NaN 6 MAP4K4 O95819 NaN 7 LATS1 O95835 NaN 8 LATS2 Q9NRM7 NaN In\u00a0[10]: Copied! <pre>%%time\nnew_net1.connect_nodes(only_signed=True, consensus_only=False)\n</pre> %%time new_net1.connect_nodes(only_signed=True, consensus_only=False) <pre>CPU times: user 30.2 ms, sys: 14 \u03bcs, total: 30.2 ms\nWall time: 30 ms\n</pre> In\u00a0[11]: Copied! <pre>visualizer = NetworkVisualizer(new_net1, color_by='effect', noi=True)\nvisualizer.render()\n</pre> visualizer = NetworkVisualizer(new_net1, color_by='effect', noi=True) visualizer.render() <p>Note</p> <p>NB! It is important to note, that not all the databases have the same structure as Omnipath. In particular, if the columns \"consensus\" are missing, we suggest to avoid to use the flag <code>consensus</code> or <code>consensus_only</code> when using NeKo with customize databases. As a general advise, we suggest to always use <code>consensus=False</code> when you are using a database different from the Omnipath.</p> In\u00a0[12]: Copied! <pre>%%time\nnew_net1.complete_connection(maxlen=3, algorithm=\"bfs\", only_signed=True, connect_with_bias=False, consensus=False) \n</pre> %%time new_net1.complete_connection(maxlen=3, algorithm=\"bfs\", only_signed=True, connect_with_bias=False, consensus=False)  <pre>CPU times: user 1.18 s, sys: 1.08 ms, total: 1.18 s\nWall time: 1.18 s\n</pre> In\u00a0[13]: Copied! <pre>#Visualize network\nvisualizer1 = NetworkVisualizer(new_net1, color_by='effect', noi=True)\nvisualizer1.render()\n</pre> #Visualize network visualizer1 = NetworkVisualizer(new_net1, color_by='effect', noi=True) visualizer1.render() <p>NeKo's resource object relies on UniProt IDs. In cases where the user-defined database does not have UniProt IDs, NeKo offers the function to translate between different IDs. The translation module is based on the python package \"Unipressed\" (https://github.com/multimeric/Unipressed).</p> <p>In the example below, we use the HURI database (http://www.interactome-atlas.org/) which provides protein-protein interactions (ppi) with ENSEMBL IDs.</p> <p>To run the following example, please download the database at the following link: http://www.interactome-atlas.org/download. The example uses the <code>HI-Union</code> version of the database in <code>.tsv</code> format.</p> In\u00a0[13]: Copied! <pre>#Import the module\nfrom neko.inputs.db_translator import IDTranslator\n</pre> #Import the module from neko.inputs.db_translator import IDTranslator <p>The <code>IDTranslator</code> function receives as arguments the input and output file names, together with the existing IDs and the target ones (in that case Ensembl to UniProtKB IDs).</p> <p>Note</p> <p>NB! The <code>IDTranslator</code> can take several minutes the first time you translate a database, depending on the size of the database.</p> In\u00a0[43]: Copied! <pre>translator = IDTranslator('HI-union.tsv', 'genes_translated.csv', 'Ensembl', 'UniProtKB-Swiss-Prot', has_header=False, input_columns=['source', 'target'], processes=12)\n</pre> translator = IDTranslator('HI-union.tsv', 'genes_translated.csv', 'Ensembl', 'UniProtKB-Swiss-Prot', has_header=False, input_columns=['source', 'target'], processes=12) In\u00a0[44]: Copied! <pre>%%time\ntranslator.run()\n</pre> %%time translator.run() <pre>2024-07-22 12:03:12,217 - IDTranslator_140412855874560 - INFO - Starting ID translation process from Ensembl to UniProtKB-Swiss-Prot</pre> <pre>INFO:IDTranslator_140412855874560:Starting ID translation process from Ensembl to UniProtKB-Swiss-Prot\n</pre> <pre>2024-07-22 12:03:12,301 - IDTranslator_140412855874560 - INFO - Loaded 64006 rows with 9094 unique IDs</pre> <pre>INFO:IDTranslator_140412855874560:Loaded 64006 rows with 9094 unique IDs\n</pre> <pre>2024-07-22 12:03:12,314 - IDTranslator_140412855874560 - INFO - Loaded progress from checkpoint_batch_91.pkl</pre> <pre>INFO:IDTranslator_140412855874560:Loaded progress from checkpoint_batch_91.pkl\n</pre> <pre>Processing batches: 0it [00:00, ?it/s]</pre> <pre>2024-07-22 12:03:12,627 - IDTranslator_140412855874560 - INFO - Applying translation to dataframe...</pre> <pre>INFO:IDTranslator_140412855874560:Applying translation to dataframe...\n</pre> <pre>2024-07-22 12:05:01,954 - IDTranslator_140412855874560 - INFO - Results saved to genes_translated.csv</pre> <pre>INFO:IDTranslator_140412855874560:Results saved to genes_translated.csv\n</pre> <pre>2024-07-22 12:05:02,150 - IDTranslator_140412855874560 - INFO - ID translation process completed in 109.93 seconds</pre> <pre>INFO:IDTranslator_140412855874560:ID translation process completed in 109.93 seconds\n</pre> <pre>2024-07-22 12:05:02,170 - IDTranslator_140412855874560 - INFO - Original entry count: 64065</pre> <pre>INFO:IDTranslator_140412855874560:Original entry count: 64065\n</pre> <pre>2024-07-22 12:05:02,173 - IDTranslator_140412855874560 - INFO - Translated entry count: 64065</pre> <pre>INFO:IDTranslator_140412855874560:Translated entry count: 64065\n</pre> <pre>2024-07-22 12:05:02,178 - IDTranslator_140412855874560 - INFO - Expansion factor: 1.00</pre> <pre>INFO:IDTranslator_140412855874560:Expansion factor: 1.00\n</pre> <pre>2024-07-22 12:05:02,182 - IDTranslator_140412855874560 - INFO - Translation success rate: 100.00%</pre> <pre>INFO:IDTranslator_140412855874560:Translation success rate: 100.00%\n</pre> <pre>CPU times: user 1min 49s, sys: 727 ms, total: 1min 49s\nWall time: 1min 49s\n</pre> In\u00a0[45]: Copied! <pre>translator.remove_untranslated_entries()\n</pre> translator.remove_untranslated_entries() <pre>2024-07-22 12:05:02,439 - IDTranslator_140412855874560 - INFO - Results saved to genes_translated_cleaned.csv</pre> <pre>INFO:IDTranslator_140412855874560:Results saved to genes_translated_cleaned.csv\n</pre> <pre>2024-07-22 12:05:02,442 - IDTranslator_140412855874560 - INFO - Removed 0 untranslated entries.</pre> <pre>INFO:IDTranslator_140412855874560:Removed 0 untranslated entries.\n</pre> <pre>2024-07-22 12:05:02,446 - IDTranslator_140412855874560 - INFO - Cleaned database saved to genes_translated_cleaned.csv</pre> <pre>INFO:IDTranslator_140412855874560:Cleaned database saved to genes_translated_cleaned.csv\n</pre> <pre>2024-07-22 12:05:02,450 - IDTranslator_140412855874560 - INFO - Original entry count: 64065</pre> <pre>INFO:IDTranslator_140412855874560:Original entry count: 64065\n</pre> <pre>2024-07-22 12:05:02,453 - IDTranslator_140412855874560 - INFO - Cleaned entry count: 64065</pre> <pre>INFO:IDTranslator_140412855874560:Cleaned entry count: 64065\n</pre> <pre>2024-07-22 12:05:02,472 - IDTranslator_140412855874560 - INFO - Original entry count: 64065</pre> <pre>INFO:IDTranslator_140412855874560:Original entry count: 64065\n</pre> <pre>2024-07-22 12:05:02,475 - IDTranslator_140412855874560 - INFO - Translated entry count: 64065</pre> <pre>INFO:IDTranslator_140412855874560:Translated entry count: 64065\n</pre> <pre>2024-07-22 12:05:02,479 - IDTranslator_140412855874560 - INFO - Expansion factor: 1.00</pre> <pre>INFO:IDTranslator_140412855874560:Expansion factor: 1.00\n</pre> <pre>2024-07-22 12:05:02,483 - IDTranslator_140412855874560 - INFO - Translation success rate: 100.00%</pre> <pre>INFO:IDTranslator_140412855874560:Translation success rate: 100.00%\n</pre> In\u00a0[14]: Copied! <pre>huri = pd.read_csv(\"genes_translated_cleaned.csv\", usecols=[\"source_UniProtKB-Swiss-Prot\", \"target_UniProtKB-Swiss-Prot\"])\n</pre> huri = pd.read_csv(\"genes_translated_cleaned.csv\", usecols=[\"source_UniProtKB-Swiss-Prot\", \"target_UniProtKB-Swiss-Prot\"]) In\u00a0[15]: Copied! <pre>huri.head()\n</pre> huri.head() Out[15]: source_UniProtKB-Swiss-Prot target_UniProtKB-Swiss-Prot 0 Q9H2S6 Q9NPE6 1 Q9H2S6 Q9BXK5 2 Q9H2S6 O60238 3 Q9H2S6 P20138 4 Q9H2S6 Q9UM44 In\u00a0[27]: Copied! <pre>resources = Universe()\n</pre> resources = Universe() In\u00a0[28]: Copied! <pre>mapping = {\"source_UniProtKB-Swiss-Prot\": \"source\", \"target_UniProtKB-Swiss-Prot\": \"target\"}\nresources.add_resources(huri, columns=mapping,  reset_index=True)\n</pre> mapping = {\"source_UniProtKB-Swiss-Prot\": \"source\", \"target_UniProtKB-Swiss-Prot\": \"target\"} resources.add_resources(huri, columns=mapping,  reset_index=True) In\u00a0[29]: Copied! <pre>resources.build()\n</pre> resources.build() In\u00a0[30]: Copied! <pre>resources.interactions\n</pre> resources.interactions Out[30]: source target is_directed is_stimulation is_inhibition form_complex 0 Q9H2S6 Q9NPE6 False False False False 1 Q9H2S6 Q9BXK5 False False False False 2 Q9H2S6 O60238 False False False False 3 Q9H2S6 P20138 False False False False 4 Q9H2S6 Q9UM44 False False False False ... ... ... ... ... ... ... 64060 B2RXH8 B2RXH8 False False False False 64061 Q8NHW4 Q6IN84 False False False False 64062 ENSG00000276076 ENSG00000276076 False False False False 64063 Q9UI36 Q9UI36 False False False False 64064 ENSG00000280987 ENSG00000280987 False False False False <p>64065 rows \u00d7 6 columns</p> In\u00a0[31]: Copied! <pre>genes = [\"CD33\", \"TNMD\", \"AMIGO1\"]\n</pre> genes = [\"CD33\", \"TNMD\", \"AMIGO1\"] In\u00a0[32]: Copied! <pre>new_net1 = Network(genes, resources=resources.interactions)\n</pre> new_net1 = Network(genes, resources=resources.interactions) In\u00a0[33]: Copied! <pre>new_net1.connect_network_radially(max_len=1, only_signed=False, consensus=False)\n</pre> new_net1.connect_network_radially(max_len=1, only_signed=False, consensus=False) In\u00a0[34]: Copied! <pre>visualizer = NetworkVisualizer(new_net1, color_by='effect')\nvisualizer.render()\n</pre> visualizer = NetworkVisualizer(new_net1, color_by='effect') visualizer.render() In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"tutorials/2_add_resources/#build-network-using-user-defined-resources","title":"Build network using user-defined resources\u00b6","text":"<p>This notebook explores how to add other individual resources from Omnipath or other public databases.</p>"},{"location":"tutorials/2_add_resources/#1-adding-a-resource-already-in-omnipath","title":"1. Adding a resource already in OmniPath\u00b6","text":""},{"location":"tutorials/2_add_resources/#1a-specify-the-interaction-resource-of-interest","title":"1A. Specify the interaction resource of interest\u00b6","text":""},{"location":"tutorials/2_add_resources/#1b-add-new-resource-to-the-resources-object","title":"1B. Add new resource to the Resources object\u00b6","text":""},{"location":"tutorials/2_add_resources/#2-adding-a-public-database","title":"2. Adding a public database\u00b6","text":"<p>Alternatively, the user might want to use their own interaction databases. We have already implemented the inclusion of some of widely used databases.</p> <p>As example, we show here how to integrate the Signor 3.0 database. In order to do so, the User needs to have already downloaded the whole Signor database, available at the following link: https://signor.uniroma2.it/downloads.php or with the following code:.</p>"},{"location":"tutorials/2_add_resources/#2a-add-signor-database","title":"2A. Add Signor database\u00b6","text":""},{"location":"tutorials/2_add_resources/","title":"\u00b6","text":"<p>Note</p> <p>SIGNOR uses has different identifiers for complexes, protein family, phenotype, etc. It is possible that the network contains nodes names like \"Signor_pf32\" or something like this... This is not yet translated, but if you are interested in what those nodes consist of, you can use download their vocabulary for the entities: https://signor.uniroma2.it/downloads.php</p>"},{"location":"tutorials/2_add_resources/#3-build-the-network","title":"3. Build the network\u00b6","text":""},{"location":"tutorials/2_add_resources/#3a-import-genes-as-network-nodes","title":"3A. Import genes as network nodes\u00b6","text":""},{"location":"tutorials/2_add_resources/#3b-create-network-object-by-specifying-the-interaction-resources","title":"3B. Create network object by specifying the interaction resources\u00b6","text":""},{"location":"tutorials/2_add_resources/#3c-build-network","title":"3C. Build network\u00b6","text":"<p>The downstream steps to connect your nodes, are the same. Please see the Network building tutorial for detailed explanations of each step.</p>"},{"location":"tutorials/2_add_resources/#4-translate-ids","title":"4. Translate IDs\u00b6","text":""},{"location":"tutorials/3_stepwise_connection/","title":"Stepwise connection: a focus on the INE algorithm","text":"In\u00a0[1]: Copied! <pre>%%time\nfrom neko.core.network import Network\nfrom neko._visual.visualize_network import NetworkVisualizer\nfrom neko.inputs import Universe, signor\nfrom neko._annotations.gene_ontology import Ontology\nimport omnipath as op\nimport pandas as pd\n</pre> %%time from neko.core.network import Network from neko._visual.visualize_network import NetworkVisualizer from neko.inputs import Universe, signor from neko._annotations.gene_ontology import Ontology import omnipath as op import pandas as pd <pre>CPU times: user 3.62 s, sys: 758 ms, total: 4.38 s\nWall time: 4.72 s\n</pre> In\u00a0[2]: Copied! <pre>genes = [\"PIK3CA\",\"MAP2K1\",\"GSK3B\",\"MAPK14\",\"CTNNB1\",\"AKT1\",\"MAP3K7\"]\n</pre> genes = [\"PIK3CA\",\"MAP2K1\",\"GSK3B\",\"MAPK14\",\"CTNNB1\",\"AKT1\",\"MAP3K7\"] In\u00a0[3]: Copied! <pre>output_nodes_prosurvival = ['CCND1','MYC','TCF7L2']\n</pre> output_nodes_prosurvival = ['CCND1','MYC','TCF7L2'] In\u00a0[4]: Copied! <pre>resources = signor()  # this function accept only tab separated values\nresources.build()\n</pre> resources = signor()  # this function accept only tab separated values resources.build() In\u00a0[5]: Copied! <pre>new_net = Network(initial_nodes = genes, resources=resources.interactions)\n</pre> new_net = Network(initial_nodes = genes, resources=resources.interactions) In\u00a0[6]: Copied! <pre>%%time\nnew_net.connect_as_atopo(max_len=1, strategy=\"radial\",outputs=output_nodes_prosurvival)\n</pre> %%time new_net.connect_as_atopo(max_len=1, strategy=\"radial\",outputs=output_nodes_prosurvival) <pre>CPU times: user 6.91 s, sys: 6.27 ms, total: 6.92 s\nWall time: 6.92 s\n</pre> In\u00a0[7]: Copied! <pre>new_net.edges\n</pre> new_net.edges Out[7]: source target Type Effect References Provenance 0 Q16539 SIGNOR-PF24 None bimodal 20626350; 12181443 None 1 Q16539 P04150 None stimulation 20660302; 15817653 None 2 Q16539 P11362 None inhibition 20626350 None 3 Q16539 Q15750 None inhibition 19393267; 14592977 None 4 Q16539 P49841 None inhibition 18451303; 17726008 None ... ... ... ... ... ... ... 261 P35222 P01106 None stimulation 16510874 None 263 P49840 P01106 None inhibition 16023596 None 266 Q16539 P24385 None inhibition 8702807 None 269 P01106 P24385 None stimulation 12835716 None 270 SIGNOR-PF1 P01106 None stimulation 11018017 None <p>178 rows \u00d7 6 columns</p> In\u00a0[8]: Copied! <pre>visualizer = NetworkVisualizer(new_net, color_by='effect', noi=True)\nvisualizer.render()\n</pre> visualizer = NetworkVisualizer(new_net, color_by='effect', noi=True) visualizer.render() In\u00a0[9]: Copied! <pre>visualizer = NetworkVisualizer(new_net, color_by='effect', noi=True, predefined_node=\"CCND1\")\nvisualizer.render()\n</pre> visualizer = NetworkVisualizer(new_net, color_by='effect', noi=True, predefined_node=\"CCND1\") visualizer.render() In\u00a0[10]: Copied! <pre>visualizer = NetworkVisualizer(new_net, color_by='effect', noi=True, predefined_node=\"MYC\")\nvisualizer.render()\n</pre> visualizer = NetworkVisualizer(new_net, color_by='effect', noi=True, predefined_node=\"MYC\") visualizer.render() In\u00a0[11]: Copied! <pre>visualizer = NetworkVisualizer(new_net, color_by='effect', noi=True, predefined_node=\"TCF7L2\")\nvisualizer.render()\n</pre> visualizer = NetworkVisualizer(new_net, color_by='effect', noi=True, predefined_node=\"TCF7L2\") visualizer.render()"},{"location":"tutorials/3_stepwise_connection/#stepwise-connection-a-focus-on-the-ine-algorithm","title":"Stepwise connection: a focus on the INE algorithm\u00b6","text":"<p>This notebook provides the steps to build a network starting from a list of genes, and using the Iterative Neighbor Expansion (INE) algorithm.</p>"},{"location":"tutorials/3_stepwise_connection/#1-define-the-list-of-genes-of-interest","title":"1. Define the list of genes of interest\u00b6","text":""},{"location":"tutorials/3_stepwise_connection/#2-specify-signor-resource","title":"2. Specify SIGNOR resource\u00b6","text":""},{"location":"tutorials/3_stepwise_connection/#3-create-a-network-using-as-input-the-gene-set","title":"3. Create a network using as input the gene set.\u00b6","text":""},{"location":"tutorials/3_stepwise_connection/#3a-import-genes-as-network-nodes","title":"3A. Import genes as network nodes\u00b6","text":""},{"location":"tutorials/3_stepwise_connection/#3b-connect-nodes","title":"3B. Connect nodes\u00b6","text":"<p>The INE algorith connects the input nodes by looking and introducing all their immediate neighbors into the network. If the nodes remain unconnected, the immediate neighbors of the newly introduced nodes are added into the network. The process ends either when a complete network is reached or until the user-specified threshold of expansion steps (i.e., <code>max_len</code>) is specified.</p> <p>The algorithm also allows the definition of <code>outputs</code>, which are nodes that should be connected to the network with only incoming edges. For instance, these nodes might represent phenotypic markers (e.g., proliferation) of interest.</p> <p>At the end of the algorithm, any nodes that do not have a source in the edge dataframe and are not in  the output node are removed..</p>"},{"location":"tutorials/4_Connect_upstream/","title":"Connect to upstream components","text":"In\u00a0[1]: Copied! <pre>%%time\nfrom neko.core.network import Network\nfrom neko._visual.visualize_network import NetworkVisualizer\nfrom neko.inputs import Universe\nfrom neko._annotations.gene_ontology import Ontology\nimport omnipath as op\n</pre> %%time from neko.core.network import Network from neko._visual.visualize_network import NetworkVisualizer from neko.inputs import Universe from neko._annotations.gene_ontology import Ontology import omnipath as op <pre>CPU times: user 3.51 s, sys: 912 ms, total: 4.42 s\nWall time: 4.32 s\n</pre> In\u00a0[2]: Copied! <pre>collectri = op.interactions.CollecTRI.get()\n</pre> collectri = op.interactions.CollecTRI.get() In\u00a0[3]: Copied! <pre>resources = Universe()\nresources.add_resources(collectri, name = 'collectri')\nresources.build()\n</pre> resources = Universe() resources.add_resources(collectri, name = 'collectri') resources.build() In\u00a0[4]: Copied! <pre>genes = [\"SRC\", \"NOTCH1\", \"CDH1\", \"CDH2\", \"VIM\", \"LATS1\", \"LATS2\"]\n</pre> genes = [\"SRC\", \"NOTCH1\", \"CDH1\", \"CDH2\", \"VIM\", \"LATS1\", \"LATS2\"] In\u00a0[5]: Copied! <pre>new_net1 = Network(genes, resources = resources.interactions)\n</pre> new_net1 = Network(genes, resources = resources.interactions) In\u00a0[6]: Copied! <pre>%%time\nnew_net1.connect_to_upstream_nodes(rank = 1, depth=2)\n</pre> %%time new_net1.connect_to_upstream_nodes(rank = 1, depth=2) <pre>Warning: Some target genes are not present in the DataFrame and will be ignored: {'O96006'}\nCPU times: user 1.15 s, sys: 6.1 ms, total: 1.16 s\nWall time: 1.16 s\n</pre> In\u00a0[7]: Copied! <pre>visualizer = NetworkVisualizer(new_net1, color_by='effect', noi=True)\nvisualizer.render()\n</pre> visualizer = NetworkVisualizer(new_net1, color_by='effect', noi=True) visualizer.render()"},{"location":"tutorials/4_Connect_upstream/#connect-to-upstream-components","title":"Connect to upstream components\u00b6","text":"<p>This notebook shows a new functionality of the tool to connect the input gene list. Instead of looking for a path, as the default connecting strategy of the tool, this functionality aims to find those upstream regulators that regulate as many of the input genes.</p>"},{"location":"tutorials/4_Connect_upstream/#1-import-collectri-interactions-from-omnipath","title":"1. Import CollecTRI interactions from Omnipath\u00b6","text":""},{"location":"tutorials/4_Connect_upstream/#2-define-the-nodes-of-interest-and-create-network-object-with-collectri-interactions","title":"2. Define the nodes of interest and create network object with CollecTRI interactions\u00b6","text":""},{"location":"tutorials/4_Connect_upstream/#3-connect-nodes-to-upstream-regulators","title":"3. Connect nodes to upstream regulators\u00b6","text":"<p>The <code>connect_to_upstream_nodes</code> looks for the regulators of each of the input nodes, and ranks each of the regulators based on the number of the input nodes they regulate.</p> <p>The <code>rank</code> argument refers to the number of the ranked regulators that should be included in the network The <code>depth</code> argument refers to how many steps away from the input nodes the algorithm should go. The higher the number the more regulatory layers will be included in the final network.</p>"},{"location":"tutorials/5_build_phosphosite_network/","title":"Build network based on kinase-phosphosite interactions","text":"In\u00a0[1]: Copied! <pre>%%time\nfrom neko.core.network import Network\nfrom neko._visual.visualize_network import NetworkVisualizer\nfrom neko.inputs import Universe, phosphosite\nfrom neko._annotations.gene_ontology import Ontology\nimport omnipath as op\nimport pandas as pd\n</pre> %%time from neko.core.network import Network from neko._visual.visualize_network import NetworkVisualizer from neko.inputs import Universe, phosphosite from neko._annotations.gene_ontology import Ontology import omnipath as op import pandas as pd <pre>CPU times: user 3.53 s, sys: 835 ms, total: 4.37 s\nWall time: 4.28 s\n</pre> In\u00a0[2]: Copied! <pre>resources = phosphosite()\n</pre> resources = phosphosite() <pre>/home/mruscone/Desktop/github/Neko/test_env/lib/python3.12/site-packages/neko/inputs/_db/_misc.py:21: FutureWarning: Downcasting behavior in `replace` is deprecated and will be removed in a future version. To retain the old behavior, explicitly call `result.infer_objects(copy=False)`. To opt-in to the future behavior, set `pd.set_option('future.no_silent_downcasting', True)`\n  df[col] = df[col].replace(mappings)\n/home/mruscone/Desktop/github/Neko/test_env/lib/python3.12/site-packages/neko/inputs/_db/_misc.py:21: FutureWarning: Downcasting behavior in `replace` is deprecated and will be removed in a future version. To retain the old behavior, explicitly call `result.infer_objects(copy=False)`. To opt-in to the future behavior, set `pd.set_option('future.no_silent_downcasting', True)`\n  df[col] = df[col].replace(mappings)\n</pre> In\u00a0[3]: Copied! <pre>genes = ['AKT1S1_T246', 'GSK3B_S9', 'AKT1_S473', 'HSPB1_S78', 'HSPB1_S82', 'MAPK14_T180', 'MAPK14_Y182', 'MAP2K1_S218', 'MAP2K1_S222', 'RPS6KA1_S380', 'MTOR_S2448', 'JUN_S63', 'MAPK3_T202', 'MAPK3_Y204']\n</pre> genes = ['AKT1S1_T246', 'GSK3B_S9', 'AKT1_S473', 'HSPB1_S78', 'HSPB1_S82', 'MAPK14_T180', 'MAPK14_Y182', 'MAP2K1_S218', 'MAP2K1_S222', 'RPS6KA1_S380', 'MTOR_S2448', 'JUN_S63', 'MAPK3_T202', 'MAPK3_Y204'] In\u00a0[7]: Copied! <pre>%%time\nnew_net1 = Network(genes, resources=resources.interactions)\n</pre> %%time new_net1 = Network(genes, resources=resources.interactions) <pre>CPU times: user 203 ms, sys: 2.08 ms, total: 205 ms\nWall time: 205 ms\n</pre> <p>Note</p> <p>Neko is based on UniProt IDs. It is still possible to use databases with other IDs, but an error message will appear during the translation progress, as in the example below.</p> In\u00a0[8]: Copied! <pre>%%time\nnew_net1.complete_connection(algorithm= 'bfs', maxlen=None, only_signed=True, connect_with_bias=True)\n</pre> %%time new_net1.complete_connection(algorithm= 'bfs', maxlen=None, only_signed=True, connect_with_bias=True) <pre>CPU times: user 1.09 s, sys: 368 \u03bcs, total: 1.09 s\nWall time: 1.09 s\n</pre> In\u00a0[9]: Copied! <pre>visualizer1 = NetworkVisualizer(new_net1, color_by='effect')\nvisualizer1.render()\n</pre> visualizer1 = NetworkVisualizer(new_net1, color_by='effect') visualizer1.render()"},{"location":"tutorials/5_build_phosphosite_network/#build-network-based-on-kinase-phosphosite-interactions","title":"Build network based on kinase-phosphosite interactions\u00b6","text":"<p>This notebook provides the code to create a network based on kinase-substrate interactions and the annotated effect of phosphorylation (based on PhosphositePlus) on the activity of the substrate.</p>"},{"location":"tutorials/5_build_phosphosite_network/#1-specify-kinase-substrate-interaction-file-and-phosphosite-effect-annotation","title":"1. Specify kinase-substrate interaction file and phosphosite effect annotation\u00b6","text":"<p>In this example, both files we utilize are from PhosphositePlus.</p>"},{"location":"tutorials/5_build_phosphosite_network/#2-add-interactions-as-a-resource-database","title":"2. Add interactions as a resource database\u00b6","text":"<p>The _process_psp_interactions_ function parses the provided files to create an interaction database in the Omnipath format.</p>"},{"location":"tutorials/5_build_phosphosite_network/#3-define-a-set-of-phosphosites-we-are-interested-in","title":"3. Define a set of phosphosites we are interested in\u00b6","text":""},{"location":"tutorials/5_build_phosphosite_network/#4-build-network","title":"4. Build network\u00b6","text":""},{"location":"tutorials/6_ontology/","title":"Connect to downstream Gene Ontology terms.","text":"In\u00a0[1]: Copied! <pre>%%time\nfrom neko.core.network import Network\nfrom neko._visual.visualize_network import NetworkVisualizer\nfrom neko.inputs import Universe\nfrom neko._annotations.gene_ontology import Ontology\nimport omnipath as op\n</pre> %%time from neko.core.network import Network from neko._visual.visualize_network import NetworkVisualizer from neko.inputs import Universe from neko._annotations.gene_ontology import Ontology import omnipath as op <pre>CPU times: user 3.46 s, sys: 872 ms, total: 4.34 s\nWall time: 4.19 s\n</pre> In\u00a0[2]: Copied! <pre>genes = [\"SRC\", \"NOTCH1\", \"FAK\"]\n</pre> genes = [\"SRC\", \"NOTCH1\", \"FAK\"] In\u00a0[3]: Copied! <pre>new_net1 = Network(genes, resources = 'omnipath')\n</pre> new_net1 = Network(genes, resources = 'omnipath') In\u00a0[4]: Copied! <pre>%%time\nnew_net1.connect_nodes(only_signed=True, consensus_only=True)\n</pre> %%time new_net1.connect_nodes(only_signed=True, consensus_only=True) <pre>CPU times: user 34.7 ms, sys: 250 \u03bcs, total: 35 ms\nWall time: 34.5 ms\n</pre> In\u00a0[5]: Copied! <pre>%%time\nnew_net1.connect_genes_to_phenotype(id_accession=\"GO:0001837\", phenotype=\"epithelial to mesenchymal transition\", only_signed=True, compress=True, maxlen=1)\n</pre> %%time new_net1.connect_genes_to_phenotype(id_accession=\"GO:0001837\", phenotype=\"epithelial to mesenchymal transition\", only_signed=True, compress=True, maxlen=1) <pre>Start requesting genes from Gene Ontology\nFetching from:  https://golr-aux.geneontology.io/solr/select?defType=edismax&amp;qt=standard&amp;indent=on&amp;wt=csv&amp;rows=100000&amp;start=0&amp;fl=bioentity_label&amp;facet=true&amp;facet.mincount=1&amp;facet.sort=count&amp;json.nl=arrarr&amp;facet.limit=25&amp;hl=true&amp;hl.simple.pre=%3Cem%20class=%22hilite%22%3E&amp;hl.snippets=1000&amp;csv.encapsulator=&amp;csv.separator=%09&amp;csv.header=false&amp;csv.mv.separator=%7C&amp;fq=document_category:%22annotation%22&amp;fq=isa_partof_closure:%22GO:0001837%22&amp;fq=taxon_subset_closure_label:%22Homo%20sapiens%22&amp;fq=type:%22protein%22&amp;fq=annotation_class_label:%22epithelial%20to%20mesenchymal%20transition%22&amp;facet.field=aspect&amp;facet.field=taxon_subset_closure_label&amp;facet.field=type&amp;facet.field=evidence_subset_closure_label&amp;facet.field=regulates_closure_label&amp;facet.field=isa_partof_closure_label&amp;facet.field=annotation_class_label&amp;facet.field=qualifier&amp;facet.field=annotation_extension_class_closure_label&amp;facet.field=assigned_by&amp;facet.field=panther_family_label&amp;q=*:*\nDone\nStarting connecting network's nodes to: ['FBXO11', 'BMP2', 'FOXF2', 'NOTCH4', 'SMAD4', 'SPSB3', 'SOX9', 'ROCK2', 'SNAI2', 'TGFB1', 'CTNNB1', 'DACT3', 'TGFBR3L', 'TRIM28', 'DDX5', 'TGFBR1', 'LEF1', 'SLC39A10', 'IGF1', 'DDX17', 'TGFB2', 'S100A4', 'WNT5A', 'WNT11', 'HNRNPAB', 'DLG5', 'PPP3R1', 'NOTCH1', 'RNF7', 'TGFBR3', 'LIMS1', 'SNAI1', 'WNT4', 'HIF1A', 'FAM83D', 'ROCK1', 'AMELX', 'LOXL3', 'KAT8', 'KDM1A', 'RBX1', 'BMP7', 'RBPJ', 'AKNA', 'SP6', 'HGF', 'HMGA2', 'GSK3B', 'CUL7', 'NOG', 'SLC39A6', 'LOXL2', 'CUL5', 'MSX1', 'EPB41L5', 'NCAM1', 'FGFR2', 'RFLNB', 'TGFBR2', 'FGFR1']\nCPU times: user 230 ms, sys: 1.95 ms, total: 232 ms\nWall time: 1.34 s\n</pre> In\u00a0[6]: Copied! <pre>#Visualize network\nvisualizer1 = NetworkVisualizer(new_net1, color_by='effect')\nvisualizer1.render()\n</pre> #Visualize network visualizer1 = NetworkVisualizer(new_net1, color_by='effect') visualizer1.render() In\u00a0[7]: Copied! <pre>new_net1.edges\n</pre> new_net1.edges Out[7]: source target Type Effect References 0 P12931 Q05397 None stimulation Adhesome:10085298;Adhesome:10592173;Adhesome:1... 1 P12931 epithelial_to_mesenchymal_transition None inhibition InnateDB:18840094 2 P46531 epithelial_to_mesenchymal_transition None stimulation HPRD:11604490;NetPath:11604490;SPIKE:11604490;... 3 Q05397 epithelial_to_mesenchymal_transition None stimulation None 4 P46531 epithelial_to_mesenchymal_transition NaN stimulation Gene Ontology"},{"location":"tutorials/6_ontology/#connect-to-downstream-gene-ontology-terms","title":"Connect to downstream Gene Ontology terms.\u00b6","text":"<p>This notebook showcases the functionality of Omniflow that connects the existing nodes of a network to a phenotype of interest.</p>"},{"location":"tutorials/6_ontology/#1-build-network","title":"1. Build network\u00b6","text":"<p>Please see the Network building tutorial for detailed explanations of each step.</p>"},{"location":"tutorials/6_ontology/#2-connect-to-gene-ontology-go-term","title":"2. Connect to Gene Ontology (GO) term\u00b6","text":"<p>Connect the nodes of the Network with markers of a certain phenotype, from Gene Ontology.</p> <p>The connect_genes_to_phenotype function will look for interactions between the nodes of the network and genes annotated with a GO term of interest. The argument compress replaces the individual phenotype-specific genes into one phenotype node.</p> <p>Note</p> <p>We suggest to the users to choose gene ontology terms lower in the hierarcy (e.g., execution phase of apoptosis versus apoptosis) to avoid the inclusion of too many genes.</p>"},{"location":"tutorials/7_tissue_mapping/","title":"Map tissue expression","text":"In\u00a0[1]: Copied! <pre>%%time\nfrom neko.core.network import Network\nfrom neko._visual.visualize_network import NetworkVisualizer\nfrom neko.inputs import Universe\nfrom neko._annotations.gene_ontology import Ontology\nimport omnipath as op\n</pre> %%time from neko.core.network import Network from neko._visual.visualize_network import NetworkVisualizer from neko.inputs import Universe from neko._annotations.gene_ontology import Ontology import omnipath as op <pre>CPU times: user 6.01 s, sys: 1.56 s, total: 7.57 s\nWall time: 5.17 s\n</pre> In\u00a0[2]: Copied! <pre>genes = [\"SRC\", \"NOTCH1\", \"FAK\", \"CDH1\", \"CDH2\", \"VIM\", \"MAP4K4\", \"LATS1\", \"LATS2\", \"PTK2B\"]\n</pre> genes = [\"SRC\", \"NOTCH1\", \"FAK\", \"CDH1\", \"CDH2\", \"VIM\", \"MAP4K4\", \"LATS1\", \"LATS2\", \"PTK2B\"] In\u00a0[3]: Copied! <pre>new_net1 = Network(genes, resources = 'omnipath')\n</pre> new_net1 = Network(genes, resources = 'omnipath') In\u00a0[4]: Copied! <pre>#Print node dataframe\nnew_net1.nodes\n</pre> #Print node dataframe new_net1.nodes Out[4]: Genesymbol Uniprot Type 0 SRC P12931 NaN 1 NOTCH1 P46531 NaN 2 PTK2 Q05397 NaN 3 CDH1 P12830 NaN 4 CDH2 P19022 NaN 5 VIM P08670 NaN 6 MAP4K4 O95819 NaN 7 LATS1 O95835 NaN 8 LATS2 Q9NRM7 NaN 9 PTK2B Q14289 NaN In\u00a0[5]: Copied! <pre>annot = Ontology()\nresults_df = annot.check_tissue_annotations(genes_df = new_net1.nodes, tissue = 'colorectal cancer')\nprint(results_df)\n</pre> annot = Ontology() results_df = annot.check_tissue_annotations(genes_df = new_net1.nodes, tissue = 'colorectal cancer') print(results_df) <pre>0.00B [00:00, ?B/s]</pre> <pre>0.00B [00:00, ?B/s]</pre> <pre>0.00B [00:00, ?B/s]</pre> <pre>0.00B [00:00, ?B/s]</pre> <pre>0.00B [00:00, ?B/s]</pre> <pre>0.00B [00:00, ?B/s]</pre> <pre>0.00B [00:00, ?B/s]</pre> <pre>0.00B [00:00, ?B/s]</pre> <pre>0.00B [00:00, ?B/s]</pre> <pre>0.00B [00:00, ?B/s]</pre> <pre>  Genesymbol  in_tissue\n0        SRC       True\n1     NOTCH1       True\n2       PTK2       True\n3       CDH1       True\n4       CDH2       True\n5        VIM       True\n6     MAP4K4       True\n7      LATS1       True\n8      LATS2       True\n9      PTK2B       True\n</pre> In\u00a0[6]: Copied! <pre>network_visualizer = NetworkVisualizer(new_net1)\nnetwork_visualizer.tissue_mapping(results_df)\nnetwork_visualizer.render()\n</pre> network_visualizer = NetworkVisualizer(new_net1) network_visualizer.tissue_mapping(results_df) network_visualizer.render() In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"tutorials/7_tissue_mapping/#map-tissue-expression","title":"Map tissue expression\u00b6","text":"<p>This notebook explores how you can explore whether the nodes in your network are expressed in a tissue of interest. The annotations are accessed from the Annotation object of Omnipath, and are based on expression data from the Human Protein Atlas.</p>"},{"location":"tutorials/7_tissue_mapping/#1-import-genes-as-network-nodes","title":"1. Import genes as network nodes\u00b6","text":""},{"location":"tutorials/7_tissue_mapping/#2-check-if-the-genes-are-annotated-in-the-tissue-of-interest-eg-in-colorectal-cancer","title":"2. Check if the genes are annotated in the tissue of interest (e.g., in colorectal cancer)\u00b6","text":""},{"location":"tutorials/7_tissue_mapping/#3-color-nodes-based-on-their-presenceabsence-in-the-tissue-of-interest","title":"3. Color nodes based on their presence/absence in the tissue of interest\u00b6","text":"<p>The <code>tissue_mapping</code> functions highligts as light blue all the nodes of the network that are expressed in the used-defined system.</p>"},{"location":"tutorials/8_Compare_networks/","title":"Network comparison","text":"In\u00a0[1]: Copied! <pre>%%time\nfrom neko.core.network import Network\nfrom neko._visual.visualize_network import NetworkVisualizer\nfrom neko.inputs import Universe\nfrom neko._annotations.gene_ontology import Ontology\nfrom neko._methods.compare import compare_networks\nimport omnipath as op\n</pre> %%time from neko.core.network import Network from neko._visual.visualize_network import NetworkVisualizer from neko.inputs import Universe from neko._annotations.gene_ontology import Ontology from neko._methods.compare import compare_networks import omnipath as op <pre>CPU times: user 5.76 s, sys: 1.66 s, total: 7.42 s\nWall time: 5.09 s\n</pre> In\u00a0[2]: Copied! <pre>genes = [\"SRC\", \"NOTCH1\", \"FAK\", \"CDH1\", \"CDH2\", \"VIM\", \"MAP4K4\", \"LATS1\", \"LATS2\", \"PTK2B\"]\n</pre> genes = [\"SRC\", \"NOTCH1\", \"FAK\", \"CDH1\", \"CDH2\", \"VIM\", \"MAP4K4\", \"LATS1\", \"LATS2\", \"PTK2B\"] In\u00a0[3]: Copied! <pre>new_net1 = Network(genes, resources = 'omnipath')\nnew_net1.connect_nodes(only_signed=True, consensus_only=True)\nnew_net1.complete_connection(maxlen=6, algorithm=\"bfs\", only_signed=True, connect_with_bias=True, consensus=True)\n</pre> new_net1 = Network(genes, resources = 'omnipath') new_net1.connect_nodes(only_signed=True, consensus_only=True) new_net1.complete_connection(maxlen=6, algorithm=\"bfs\", only_signed=True, connect_with_bias=True, consensus=True) In\u00a0[4]: Copied! <pre>new_net2 = Network(genes, resources = 'omnipath')\nnew_net2.connect_nodes(only_signed=True, consensus_only=True)\nnew_net2.complete_connection(maxlen=3, algorithm=\"dfs\", only_signed=True, connect_with_bias=True, consensus=True)\n</pre> new_net2 = Network(genes, resources = 'omnipath') new_net2.connect_nodes(only_signed=True, consensus_only=True) new_net2.complete_connection(maxlen=3, algorithm=\"dfs\", only_signed=True, connect_with_bias=True, consensus=True) <p>The compare_networks functions receives as input the two network objects of interest. Its output is two dataframes; one for the comparison of the edges and for the comparison of nodes.</p> In\u00a0[5]: Copied! <pre>interaction_comparison, node_comparison = compare_networks(new_net1, new_net2)\n</pre> interaction_comparison, node_comparison = compare_networks(new_net1, new_net2) In\u00a0[6]: Copied! <pre>print(interaction_comparison)\n</pre> print(interaction_comparison) <pre>    source  target           comparison\n0     ABL1     APP  Unique to Network 2\n1     ABL1     BTK  Unique to Network 2\n2     ABL1    CDH2               Common\n3     ABL1  CTNNB1               Common\n4     ABL1    EGFR               Common\n..     ...     ...                  ...\n715   WNT1   ITGB4  Unique to Network 2\n716   WNT1    LEF1  Unique to Network 2\n717   WNT1  MAP3K7  Unique to Network 2\n718   WNT1  NOTCH1  Unique to Network 2\n719    ZYX     SRC               Common\n\n[720 rows x 3 columns]\n</pre> In\u00a0[7]: Copied! <pre>print(node_comparison)\n</pre> print(node_comparison) <pre>       node           comparison\n0     IKBKB  Unique to Network 1\n1     ROCK1  Unique to Network 1\n2     SNAI2  Unique to Network 1\n3     PRKG1  Unique to Network 1\n4      TP63  Unique to Network 1\n..      ...                  ...\n101   PTK2B               Common\n102    PTEN               Common\n103    CDH2               Common\n104    CDH1               Common\n105  MAP4K4               Common\n\n[106 rows x 2 columns]\n</pre>"},{"location":"tutorials/8_Compare_networks/#network-comparison","title":"Network comparison\u00b6","text":"<p>In some cases, it might be of interest to compare two networks with each other. For instance, you might want to compare an existing network with the Neko-generated network, or compare the resulting networks from two different network construction strategies.</p> <p>The following code shows the comparison of two networks, built with different input parameters of the <code>complete_connections</code> function.</p>"},{"location":"tutorials/8_Compare_networks/#1-define-the-list-of-genes-of-interest","title":"1. Define the list of genes of interest\u00b6","text":""},{"location":"tutorials/8_Compare_networks/#2-create-networks","title":"2. Create networks.\u00b6","text":"<p>Please refer to the <code>Usage</code> tutorial for a detailed explanation of each step.</p>"},{"location":"tutorials/8_Compare_networks/#2a-build-first-network","title":"2A. Build first network\u00b6","text":"<p>For the first network, we specify that we do not want to take into account the concensus sign (i.e. activation vs inhibition) for the interactions.</p>"},{"location":"tutorials/8_Compare_networks/#2b-build-second-network","title":"2B. Build second network\u00b6","text":"<p>For the second network, we set the <code>consensus</code> argument to <code>True</code>.</p>"},{"location":"tutorials/8_Compare_networks/#3-compare-networks","title":"3. Compare networks\u00b6","text":""},{"location":"tutorials/9-Recreating_famous_pathways/","title":"Re-creating famous pathways from SIGNOR and WIKIPATHWAYS using NeKo","text":"In\u00a0[1]: Copied! <pre>from neko.core.network import Network\nfrom neko._visual.visualize_network import NetworkVisualizer\nfrom neko.inputs import Universe, signor\nimport omnipath as op\n</pre> from neko.core.network import Network from neko._visual.visualize_network import NetworkVisualizer from neko.inputs import Universe, signor import omnipath as op In\u00a0[2]: Copied! <pre>mtor_nodes = [\"RPS6KA1\", \"SREBF1\", \"MTOR\", \"RPTOR\", \"INSR\", \"RPS6KB1\", \"RHEB\", \"EIF4EBP1\", \"INS\", \"PTEN\",\n             \"RPS6\", \"TFEB\", \"PIK3R1\", \"PPARGC1A\", \"PDPK1\", \"AKT1S1\", \"PPARG\", \"PIK3CA\", \"EIF4E\", \"IRS1\", \"GSK3B\", \"ULK1\"]\n</pre> mtor_nodes = [\"RPS6KA1\", \"SREBF1\", \"MTOR\", \"RPTOR\", \"INSR\", \"RPS6KB1\", \"RHEB\", \"EIF4EBP1\", \"INS\", \"PTEN\",              \"RPS6\", \"TFEB\", \"PIK3R1\", \"PPARGC1A\", \"PDPK1\", \"AKT1S1\", \"PPARG\", \"PIK3CA\", \"EIF4E\", \"IRS1\", \"GSK3B\", \"ULK1\"] In\u00a0[3]: Copied! <pre>import random\n</pre> import random In\u00a0[4]: Copied! <pre>seeds_number = 4\nrandom_seeds = random.sample(mtor_nodes, seeds_number)\n</pre> seeds_number = 4 random_seeds = random.sample(mtor_nodes, seeds_number) In\u00a0[5]: Copied! <pre>random_seeds\n</pre> random_seeds Out[5]: <pre>['AKT1S1', 'TFEB', 'SREBF1', 'RPS6']</pre> In\u00a0[6]: Copied! <pre>resources = Universe()\nresources = signor(\"../neko/_data/signor_db.tsv\")  # this function accept only tab separated values\nresources.build()\n</pre> resources = Universe() resources = signor(\"../neko/_data/signor_db.tsv\")  # this function accept only tab separated values resources.build() <p>Let's compare the function commplete_connection (based on the Reciprocal Pathway Extender algorithm) with the function connect_radially (based on the Iterative Neighbor Expansion ). We are going to create two neko_net, and apply to each of them one of the two functions. Finally, we are going to compare the resulting networks.</p> In\u00a0[7]: Copied! <pre>neko_net1 = Network(random_seeds, resources = resources.interactions)\n</pre> neko_net1 = Network(random_seeds, resources = resources.interactions) In\u00a0[8]: Copied! <pre>neko_net2 = Network(random_seeds, resources = resources.interactions)\n</pre> neko_net2 = Network(random_seeds, resources = resources.interactions) In\u00a0[9]: Copied! <pre>%%time\nneko_net1.complete_connection(maxlen=3, algorithm=\"dfs\", only_signed=True, connect_with_bias=False, consensus=False)\n</pre> %%time neko_net1.complete_connection(maxlen=3, algorithm=\"dfs\", only_signed=True, connect_with_bias=False, consensus=False) <pre>CPU times: user 402 ms, sys: 3.1 ms, total: 406 ms\nWall time: 404 ms\n</pre> In\u00a0[10]: Copied! <pre>%%time\nneko_net2.connect_network_radially(max_len=2, only_signed=True, consensus=False)\n</pre> %%time neko_net2.connect_network_radially(max_len=2, only_signed=True, consensus=False) <pre>CPU times: user 6.45 s, sys: 1.39 ms, total: 6.45 s\nWall time: 6.45 s\n</pre> <p>Now let's visualize the network:</p> In\u00a0[11]: Copied! <pre>#Visualize network\nvisualizer1 = NetworkVisualizer(neko_net1, color_by='effect', noi=True)\nvisualizer1.render(\"./img/Complete_connection_neko_net_sample\", view=True)\n</pre> #Visualize network visualizer1 = NetworkVisualizer(neko_net1, color_by='effect', noi=True) visualizer1.render(\"./img/Complete_connection_neko_net_sample\", view=True) In\u00a0[12]: Copied! <pre>#Visualize network\nvisualizer2 = NetworkVisualizer(neko_net2, color_by='effect', noi=True)\nvisualizer2.render(\"./img/Radial_neko_net_sample\", view=True)\n</pre> #Visualize network visualizer2 = NetworkVisualizer(neko_net2, color_by='effect', noi=True) visualizer2.render(\"./img/Radial_neko_net_sample\", view=True) <p>Let's compare the Networks. We will use JUST those nodes in signor that are not complexes or protein families (so we excluded all those nodes that starts with \"SIGNOR_\"). At the following link you can find the full MTOR pathway from SIGNOR: https://signor.uniroma2.it/pathway_browser.php?beta=3.0&amp;organism=&amp;pathway_list=SIGNOR-MS&amp;x=13&amp;y=13</p> In\u00a0[13]: Copied! <pre>net1_nodes_size = len(neko_net1.nodes)\nnet2_nodes_size = len(neko_net2.nodes)\n\nprint(\"Number of nodes of the first NeKo network: \", net1_nodes_size)\nprint(\"Number of nodes of the second NeKo network: \", net2_nodes_size)\n</pre> net1_nodes_size = len(neko_net1.nodes) net2_nodes_size = len(neko_net2.nodes)  print(\"Number of nodes of the first NeKo network: \", net1_nodes_size) print(\"Number of nodes of the second NeKo network: \", net2_nodes_size) <pre>Number of nodes of the first NeKo network:  13\nNumber of nodes of the second NeKo network:  58\n</pre> In\u00a0[14]: Copied! <pre>net1_edges_size = len(neko_net1.edges)\nnet2_edges_size = len(neko_net2.edges)\n\nprint(\"Number of edges of the first NeKo network: \", net1_edges_size)\nprint(\"Number of edges of the second NeKo network: \", net2_edges_size)\n</pre> net1_edges_size = len(neko_net1.edges) net2_edges_size = len(neko_net2.edges)  print(\"Number of edges of the first NeKo network: \", net1_edges_size) print(\"Number of edges of the second NeKo network: \", net2_edges_size) <pre>Number of edges of the first NeKo network:  33\nNumber of edges of the second NeKo network:  161\n</pre> <p>The first consideration to do is that the RPE algorithm, is way faster than the INE one (402 ms vs 6.45 s). Despite being slower, the INE algorithm, provided a much bigger network (13 nodes vs 33, 58 edges vs 161)</p> In\u00a0[15]: Copied! <pre>nodes_found = []\nfor node in mtor_nodes:\n    if node in list(neko_net1.nodes[\"Genesymbol\"]):\n        nodes_found.append(node)\n\nprint(\"Initial nodes: \", random_seeds)\nprint(\"Nodes in the MTOR pathways: \", mtor_nodes)\nprint(\"Nodes founded: \", nodes_found)\n</pre> nodes_found = [] for node in mtor_nodes:     if node in list(neko_net1.nodes[\"Genesymbol\"]):         nodes_found.append(node)  print(\"Initial nodes: \", random_seeds) print(\"Nodes in the MTOR pathways: \", mtor_nodes) print(\"Nodes founded: \", nodes_found) <pre>Initial nodes:  ['AKT1S1', 'TFEB', 'SREBF1', 'RPS6']\nNodes in the MTOR pathways:  ['RPS6KA1', 'SREBF1', 'MTOR', 'RPTOR', 'INSR', 'RPS6KB1', 'RHEB', 'EIF4EBP1', 'INS', 'PTEN', 'RPS6', 'TFEB', 'PIK3R1', 'PPARGC1A', 'PDPK1', 'AKT1S1', 'PPARG', 'PIK3CA', 'EIF4E', 'IRS1', 'GSK3B', 'ULK1']\nNodes founded:  ['SREBF1', 'MTOR', 'RPS6KB1', 'RPS6', 'TFEB', 'AKT1S1']\n</pre> In\u00a0[16]: Copied! <pre>print(\"Percentage of genes covered: \", (len(nodes_found)/len(mtor_nodes)) * 100)\n</pre> print(\"Percentage of genes covered: \", (len(nodes_found)/len(mtor_nodes)) * 100) <pre>Percentage of genes covered:  27.27272727272727\n</pre> In\u00a0[17]: Copied! <pre>nodes_found = []\nfor node in mtor_nodes:\n    if node in list(neko_net2.nodes[\"Genesymbol\"]):\n        nodes_found.append(node)\n\nprint(\"Initial nodes: \", random_seeds)\nprint(\"Nodes in the MTOR pathways: \", mtor_nodes)\nprint(\"Nodes founded: \", nodes_found)\n</pre> nodes_found = [] for node in mtor_nodes:     if node in list(neko_net2.nodes[\"Genesymbol\"]):         nodes_found.append(node)  print(\"Initial nodes: \", random_seeds) print(\"Nodes in the MTOR pathways: \", mtor_nodes) print(\"Nodes founded: \", nodes_found) <pre>Initial nodes:  ['AKT1S1', 'TFEB', 'SREBF1', 'RPS6']\nNodes in the MTOR pathways:  ['RPS6KA1', 'SREBF1', 'MTOR', 'RPTOR', 'INSR', 'RPS6KB1', 'RHEB', 'EIF4EBP1', 'INS', 'PTEN', 'RPS6', 'TFEB', 'PIK3R1', 'PPARGC1A', 'PDPK1', 'AKT1S1', 'PPARG', 'PIK3CA', 'EIF4E', 'IRS1', 'GSK3B', 'ULK1']\nNodes founded:  ['RPS6KA1', 'SREBF1', 'MTOR', 'RPS6KB1', 'PTEN', 'RPS6', 'TFEB', 'PPARGC1A', 'AKT1S1', 'PPARG', 'GSK3B', 'ULK1']\n</pre> In\u00a0[18]: Copied! <pre>print(\"Percentage of genes covered: \", (len(nodes_found)/len(mtor_nodes)) * 100)\n</pre> print(\"Percentage of genes covered: \", (len(nodes_found)/len(mtor_nodes)) * 100) <pre>Percentage of genes covered:  54.54545454545454\n</pre> <p>As expected, due to the network size, the INE algorithm managed to capture more genes belonging to the MTOR pathway compared to the RPE algorithm. This was expected also because the RPE algorithm aims at finding the minimal set of genes that can connect all the seed nodes given by the user, while the INE algorithm does not take into account the shortest paths, but homogeneously explores the surroundings.</p> <p>The MTOR pathways we saw in use case 2 is a reletavely small pathway. We decided to test the INE and RPE algorithm to retrieve a bigger one, the EGF/EGFR pathway as shown in wikipathway, fetching interactions from Omnipath.</p> <p>In order to do so, we can proceed with the installation of the python package pywikipathways to quickly retrieve the genes belonging to the EGF/EGFR pathway (WP437, https://www.wikipathways.org/pathways/WP437.html).</p> In\u00a0[19]: Copied! <pre># uncomment the following line if you do not have installed pywikipathways\n!pip install pywikipathways\n</pre> # uncomment the following line if you do not have installed pywikipathways !pip install pywikipathways <pre>Collecting pywikipathways\n  Using cached pywikipathways-0.0.3-py3-none-any.whl.metadata (2.5 kB)\nRequirement already satisfied: lxml in /home/mruscone/Desktop/github/Neko/test_env/lib/python3.12/site-packages (from pywikipathways) (5.3.0)\nRequirement already satisfied: pandas in /home/mruscone/Desktop/github/Neko/test_env/lib/python3.12/site-packages (from pywikipathways) (2.2.2)\nRequirement already satisfied: requests in /home/mruscone/Desktop/github/Neko/test_env/lib/python3.12/site-packages (from pywikipathways) (2.32.3)\nRequirement already satisfied: numpy&gt;=1.26.0 in /home/mruscone/Desktop/github/Neko/test_env/lib/python3.12/site-packages (from pandas-&gt;pywikipathways) (1.26.4)\nRequirement already satisfied: python-dateutil&gt;=2.8.2 in /home/mruscone/Desktop/github/Neko/test_env/lib/python3.12/site-packages (from pandas-&gt;pywikipathways) (3.9.0)\nRequirement already satisfied: pytz&gt;=2020.1 in /home/mruscone/Desktop/github/Neko/test_env/lib/python3.12/site-packages (from pandas-&gt;pywikipathways) (2024.1)\nRequirement already satisfied: tzdata&gt;=2022.7 in /home/mruscone/Desktop/github/Neko/test_env/lib/python3.12/site-packages (from pandas-&gt;pywikipathways) (2024.1)\nRequirement already satisfied: six&gt;=1.5 in /home/mruscone/Desktop/github/Neko/test_env/lib/python3.12/site-packages (from python-dateutil&gt;=2.8.2-&gt;pandas-&gt;pywikipathways) (1.16.0)\nRequirement already satisfied: charset-normalizer&lt;4,&gt;=2 in /home/mruscone/Desktop/github/Neko/test_env/lib/python3.12/site-packages (from requests-&gt;pywikipathways) (3.3.2)\nRequirement already satisfied: idna&lt;4,&gt;=2.5 in /home/mruscone/Desktop/github/Neko/test_env/lib/python3.12/site-packages (from requests-&gt;pywikipathways) (3.7)\nRequirement already satisfied: urllib3&lt;3,&gt;=1.21.1 in /home/mruscone/Desktop/github/Neko/test_env/lib/python3.12/site-packages (from requests-&gt;pywikipathways) (2.2.2)\nRequirement already satisfied: certifi&gt;=2017.4.17 in /home/mruscone/Desktop/github/Neko/test_env/lib/python3.12/site-packages (from requests-&gt;pywikipathways) (2024.7.4)\nUsing cached pywikipathways-0.0.3-py3-none-any.whl (12 kB)\nInstalling collected packages: pywikipathways\nSuccessfully installed pywikipathways-0.0.3\n</pre> In\u00a0[20]: Copied! <pre>import pywikipathways as pwpw\n</pre> import pywikipathways as pwpw In\u00a0[21]: Copied! <pre>pwpw.get_pathway_info('WP437')\n</pre> pwpw.get_pathway_info('WP437') Out[21]: <pre>{'id': 'WP437',\n 'url': 'https://classic.wikipathways.org/index.php/Pathway:WP437',\n 'name': 'EGF/EGFR signaling',\n 'species': 'Homo sapiens',\n 'revision': '137261'}</pre> In\u00a0[22]: Copied! <pre>egf_egfr_genes = pwpw.get_xref_list('WP437','H')\n</pre> egf_egfr_genes = pwpw.get_xref_list('WP437','H') In\u00a0[23]: Copied! <pre>print(len(egf_egfr_genes))\negf_egfr_genes\n</pre> print(len(egf_egfr_genes)) egf_egfr_genes <pre>162\n</pre> Out[23]: <pre>['ABI1',\n 'ABL1',\n 'AKT1',\n 'AP2A1',\n 'AP2B1',\n 'AP2M1',\n 'AP2S1',\n 'ARF6',\n 'ARHGEF1',\n 'ASAP1',\n 'ATF1',\n 'ATXN2',\n 'AURKA',\n 'BCAR1',\n 'BRAF',\n 'CAMK2A',\n 'CAV1',\n 'CAV2',\n 'CBL',\n 'CBLB',\n 'CBLC',\n 'CDC42',\n 'CFL1',\n 'CREB1',\n 'CRK',\n 'CRKL',\n 'CSK',\n 'DNM1',\n 'DOK2',\n 'E2F1',\n 'EGF',\n 'EGFR',\n 'EIF4EBP1',\n 'ELK1',\n 'ELK4',\n 'EPN1',\n 'EPS15',\n 'EPS15L1',\n 'EPS8',\n 'ERBB2',\n 'ERRFI1',\n 'FOS',\n 'FOSB',\n 'FOXO1',\n 'FOXO4',\n 'GAB1',\n 'GAB2',\n 'GJA1',\n 'GRB10',\n 'GRB2',\n 'HGS',\n 'HRAS',\n 'INPP5D',\n 'INPPL1',\n 'IQGAP1',\n 'IQSEC1',\n 'ITCH',\n 'JAK1',\n 'JAK2',\n 'JUN',\n 'JUND',\n 'KRAS',\n 'LIMK2',\n 'MAP2K1',\n 'MAP2K2',\n 'MAP2K5',\n 'MAP3K1',\n 'MAP3K2',\n 'MAP3K3',\n 'MAP3K4',\n 'MAP4K1',\n 'MAPK1',\n 'MAPK14',\n 'MAPK4',\n 'MAPK7',\n 'MAPK8',\n 'MAPK9',\n 'MEF2A',\n 'MEF2C',\n 'MEF2D',\n 'MT-CO2',\n 'MTOR',\n 'MYBL2',\n 'NCK1',\n 'NCK2',\n 'NCOA3',\n 'NDUFA13',\n 'NEDD4',\n 'NEDD8',\n 'NOS3',\n 'PAK1',\n 'PCNA',\n 'PDPK1',\n 'PEBP1',\n 'PIAS3',\n 'PIK3C2B',\n 'PIK3R1',\n 'PIK3R2',\n 'PLCE1',\n 'PLCG1',\n 'PLD1',\n 'PLD2',\n 'PLSCR1',\n 'PRKCA',\n 'PRKCB',\n 'PRKCD',\n 'PRKCI',\n 'PRKCZ',\n 'PTEN',\n 'PTK2',\n 'PTK2B',\n 'PTK6',\n 'PTPN11',\n 'PTPN12',\n 'PTPN5',\n 'PTPRR',\n 'PXDN',\n 'RAB5A',\n 'RAC1',\n 'RAF1',\n 'RALA',\n 'RALB',\n 'RALBP1',\n 'RALGDS',\n 'RAP1A',\n 'RASA1',\n 'REPS2',\n 'RICTOR',\n 'RIN1',\n 'ROCK1',\n 'RPS6KA1',\n 'RPS6KA2',\n 'RPS6KA3',\n 'RPS6KA5',\n 'RPS6KB1',\n 'SH2D2A',\n 'SH3GL2',\n 'SH3GL3',\n 'SH3KBP1',\n 'SHC1',\n 'SOS1',\n 'SOS2',\n 'SP1',\n 'SPRY2',\n 'SRC',\n 'STAM',\n 'STAM2',\n 'STAMBP',\n 'STAT1',\n 'STAT3',\n 'STAT5A',\n 'STAT5B',\n 'STMN1',\n 'STXBP1',\n 'SYNJ1',\n 'TNK2',\n 'TWIST1',\n 'USP6NL',\n 'USP8',\n 'VAV1',\n 'VAV2',\n 'VAV3']</pre> <p>Let's select a random number of those genes and proceed with building the network with NeKo!</p> In\u00a0[24]: Copied! <pre>seeds_number = 20\nrandom_seeds = random.sample(egf_egfr_genes, seeds_number)\n</pre> seeds_number = 20 random_seeds = random.sample(egf_egfr_genes, seeds_number) In\u00a0[25]: Copied! <pre>random_seeds\n</pre> random_seeds Out[25]: <pre>['PEBP1',\n 'SOS1',\n 'GAB2',\n 'CDC42',\n 'CBLC',\n 'EIF4EBP1',\n 'HGS',\n 'RICTOR',\n 'PTPRR',\n 'GRB2',\n 'RAF1',\n 'RAC1',\n 'MTOR',\n 'ELK4',\n 'RPS6KA5',\n 'EPS15L1',\n 'USP6NL',\n 'PIK3R1',\n 'ABL1',\n 'PTK2']</pre> In\u00a0[26]: Copied! <pre>neko_net3 = Network(random_seeds, resources = 'omnipath')\n</pre> neko_net3 = Network(random_seeds, resources = 'omnipath') In\u00a0[27]: Copied! <pre>neko_net4 = Network(random_seeds, resources = 'omnipath')\n</pre> neko_net4 = Network(random_seeds, resources = 'omnipath') <p>Once again, now that we have created the NeKo network, let's use the RPE and INE algorithm to retrieve (hopefully) the full EGF/EGFR pathway.</p> <p>To Notice!</p> <p>Since the AllOmnipath database is very big and we have a higher number of seed nodes, the computational time / cost will be higher too! In some cases, expect both complete_connection and connect_network_radially to take minutes!</p> In\u00a0[28]: Copied! <pre>%%time\nneko_net3.complete_connection(maxlen=3, algorithm=\"dfs\", only_signed=True, connect_with_bias=False, consensus=False)\n</pre> %%time neko_net3.complete_connection(maxlen=3, algorithm=\"dfs\", only_signed=True, connect_with_bias=False, consensus=False) <pre>CPU times: user 3min 18s, sys: 24.7 ms, total: 3min 18s\nWall time: 3min 18s\n</pre> In\u00a0[29]: Copied! <pre>%%time\nneko_net4.connect_network_radially(max_len=1, only_signed=True, consensus=False)\n</pre> %%time neko_net4.connect_network_radially(max_len=1, only_signed=True, consensus=False) <pre>CPU times: user 41.7 s, sys: 3.03 ms, total: 41.7 s\nWall time: 41.7 s\n</pre> In\u00a0[30]: Copied! <pre>#This time the network are very big and it can be difficult to visualize them\n#visualizer3 = NetworkVisualizer(neko_net3, color_by='effect', noi=True)\n#visualizer3.render(\"./img/Complete_connection_neko_net_sample_EGF\", view=True)\n</pre> #This time the network are very big and it can be difficult to visualize them #visualizer3 = NetworkVisualizer(neko_net3, color_by='effect', noi=True) #visualizer3.render(\"./img/Complete_connection_neko_net_sample_EGF\", view=True) In\u00a0[31]: Copied! <pre>#Visualize network\n#visualizer4 = NetworkVisualizer(neko_net4, color_by='effect', noi=True)\n#visualizer4.render(\"./img/Radial_neko_net_sample_EGF\", view=True)\n</pre> #Visualize network #visualizer4 = NetworkVisualizer(neko_net4, color_by='effect', noi=True) #visualizer4.render(\"./img/Radial_neko_net_sample_EGF\", view=True) <p>As we did previously, let's compare network's size and check if we found nodes beloning to the EGF/EGFR pathway from wikipathway</p> In\u00a0[32]: Copied! <pre>net3_nodes_size = len(neko_net3.nodes)\nnet4_nodes_size = len(neko_net4.nodes)\n\nprint(\"Number of nodes of the third NeKo network: \", net3_nodes_size)\nprint(\"Number of nodes of the fourth NeKo network: \", net4_nodes_size)\n</pre> net3_nodes_size = len(neko_net3.nodes) net4_nodes_size = len(neko_net4.nodes)  print(\"Number of nodes of the third NeKo network: \", net3_nodes_size) print(\"Number of nodes of the fourth NeKo network: \", net4_nodes_size) <pre>Number of nodes of the third NeKo network:  284\nNumber of nodes of the fourth NeKo network:  273\n</pre> In\u00a0[33]: Copied! <pre>net3_edges_size = len(neko_net3.edges)\nnet4_edges_size = len(neko_net4.edges)\n\nprint(\"Number of edges of the third NeKo network: \", net3_edges_size)\nprint(\"Number of edges of the fourth NeKo network: \", net4_edges_size)\n</pre> net3_edges_size = len(neko_net3.edges) net4_edges_size = len(neko_net4.edges)  print(\"Number of edges of the third NeKo network: \", net3_edges_size) print(\"Number of edges of the fourth NeKo network: \", net4_edges_size) <pre>Number of edges of the third NeKo network:  5109\nNumber of edges of the fourth NeKo network:  1107\n</pre> In\u00a0[34]: Copied! <pre>nodes_found = []\nfor node in egf_egfr_genes:\n    if node in list(neko_net3.nodes[\"Genesymbol\"]):\n        nodes_found.append(node)\n\nprint(\"Initial nodes: \", random_seeds)\nprint(\"Nodes in the EGF/EGFR pathways: \", egf_egfr_genes)\nprint(\"Nodes founded: \", nodes_found)\n</pre> nodes_found = [] for node in egf_egfr_genes:     if node in list(neko_net3.nodes[\"Genesymbol\"]):         nodes_found.append(node)  print(\"Initial nodes: \", random_seeds) print(\"Nodes in the EGF/EGFR pathways: \", egf_egfr_genes) print(\"Nodes founded: \", nodes_found) <pre>Initial nodes:  ['PEBP1', 'SOS1', 'GAB2', 'CDC42', 'CBLC', 'EIF4EBP1', 'HGS', 'RICTOR', 'PTPRR', 'GRB2', 'RAF1', 'RAC1', 'MTOR', 'ELK4', 'RPS6KA5', 'EPS15L1', 'USP6NL', 'PIK3R1', 'ABL1', 'PTK2']\nNodes in the EGF/EGFR pathways:  ['ABI1', 'ABL1', 'AKT1', 'AP2A1', 'AP2B1', 'AP2M1', 'AP2S1', 'ARF6', 'ARHGEF1', 'ASAP1', 'ATF1', 'ATXN2', 'AURKA', 'BCAR1', 'BRAF', 'CAMK2A', 'CAV1', 'CAV2', 'CBL', 'CBLB', 'CBLC', 'CDC42', 'CFL1', 'CREB1', 'CRK', 'CRKL', 'CSK', 'DNM1', 'DOK2', 'E2F1', 'EGF', 'EGFR', 'EIF4EBP1', 'ELK1', 'ELK4', 'EPN1', 'EPS15', 'EPS15L1', 'EPS8', 'ERBB2', 'ERRFI1', 'FOS', 'FOSB', 'FOXO1', 'FOXO4', 'GAB1', 'GAB2', 'GJA1', 'GRB10', 'GRB2', 'HGS', 'HRAS', 'INPP5D', 'INPPL1', 'IQGAP1', 'IQSEC1', 'ITCH', 'JAK1', 'JAK2', 'JUN', 'JUND', 'KRAS', 'LIMK2', 'MAP2K1', 'MAP2K2', 'MAP2K5', 'MAP3K1', 'MAP3K2', 'MAP3K3', 'MAP3K4', 'MAP4K1', 'MAPK1', 'MAPK14', 'MAPK4', 'MAPK7', 'MAPK8', 'MAPK9', 'MEF2A', 'MEF2C', 'MEF2D', 'MT-CO2', 'MTOR', 'MYBL2', 'NCK1', 'NCK2', 'NCOA3', 'NDUFA13', 'NEDD4', 'NEDD8', 'NOS3', 'PAK1', 'PCNA', 'PDPK1', 'PEBP1', 'PIAS3', 'PIK3C2B', 'PIK3R1', 'PIK3R2', 'PLCE1', 'PLCG1', 'PLD1', 'PLD2', 'PLSCR1', 'PRKCA', 'PRKCB', 'PRKCD', 'PRKCI', 'PRKCZ', 'PTEN', 'PTK2', 'PTK2B', 'PTK6', 'PTPN11', 'PTPN12', 'PTPN5', 'PTPRR', 'PXDN', 'RAB5A', 'RAC1', 'RAF1', 'RALA', 'RALB', 'RALBP1', 'RALGDS', 'RAP1A', 'RASA1', 'REPS2', 'RICTOR', 'RIN1', 'ROCK1', 'RPS6KA1', 'RPS6KA2', 'RPS6KA3', 'RPS6KA5', 'RPS6KB1', 'SH2D2A', 'SH3GL2', 'SH3GL3', 'SH3KBP1', 'SHC1', 'SOS1', 'SOS2', 'SP1', 'SPRY2', 'SRC', 'STAM', 'STAM2', 'STAMBP', 'STAT1', 'STAT3', 'STAT5A', 'STAT5B', 'STMN1', 'STXBP1', 'SYNJ1', 'TNK2', 'TWIST1', 'USP6NL', 'USP8', 'VAV1', 'VAV2', 'VAV3']\nNodes founded:  ['ABL1', 'AKT1', 'BRAF', 'CAMK2A', 'CAV1', 'CBL', 'CBLB', 'CBLC', 'CDC42', 'CREB1', 'E2F1', 'EGF', 'EGFR', 'EIF4EBP1', 'ELK4', 'EPN1', 'EPS15', 'EPS15L1', 'ERBB2', 'FOS', 'GAB1', 'GAB2', 'GRB10', 'GRB2', 'HGS', 'HRAS', 'IQGAP1', 'JAK1', 'JAK2', 'KRAS', 'LIMK2', 'MAP2K1', 'MAP3K1', 'MAPK1', 'MAPK14', 'MAPK7', 'MAPK8', 'MAPK9', 'MTOR', 'NCK1', 'PAK1', 'PDPK1', 'PEBP1', 'PIK3R1', 'PIK3R2', 'PLCG1', 'PLD1', 'PRKCA', 'PRKCB', 'PRKCD', 'PRKCZ', 'PTEN', 'PTK2', 'PTK2B', 'PTPN11', 'PTPRR', 'RAC1', 'RAF1', 'RAP1A', 'RASA1', 'RICTOR', 'RPS6KA2', 'RPS6KA5', 'RPS6KB1', 'SH3GL2', 'SHC1', 'SOS1', 'SRC', 'STAT3', 'USP6NL', 'VAV1', 'VAV2', 'VAV3']\n</pre> In\u00a0[35]: Copied! <pre>print(\"Percentage of genes covered: \", (len(nodes_found)/len(egf_egfr_genes)) * 100)\n</pre> print(\"Percentage of genes covered: \", (len(nodes_found)/len(egf_egfr_genes)) * 100) <pre>Percentage of genes covered:  45.06172839506173\n</pre> In\u00a0[36]: Copied! <pre>nodes_found = []\nfor node in egf_egfr_genes:\n    if node in list(neko_net4.nodes[\"Genesymbol\"]):\n        nodes_found.append(node)\n\nprint(\"Initial nodes: \", random_seeds)\nprint(\"Nodes in the EGF/EGFR pathways: \", egf_egfr_genes)\nprint(\"Nodes founded: \", nodes_found)\n</pre> nodes_found = [] for node in egf_egfr_genes:     if node in list(neko_net4.nodes[\"Genesymbol\"]):         nodes_found.append(node)  print(\"Initial nodes: \", random_seeds) print(\"Nodes in the EGF/EGFR pathways: \", egf_egfr_genes) print(\"Nodes founded: \", nodes_found) <pre>Initial nodes:  ['PEBP1', 'SOS1', 'GAB2', 'CDC42', 'CBLC', 'EIF4EBP1', 'HGS', 'RICTOR', 'PTPRR', 'GRB2', 'RAF1', 'RAC1', 'MTOR', 'ELK4', 'RPS6KA5', 'EPS15L1', 'USP6NL', 'PIK3R1', 'ABL1', 'PTK2']\nNodes in the EGF/EGFR pathways:  ['ABI1', 'ABL1', 'AKT1', 'AP2A1', 'AP2B1', 'AP2M1', 'AP2S1', 'ARF6', 'ARHGEF1', 'ASAP1', 'ATF1', 'ATXN2', 'AURKA', 'BCAR1', 'BRAF', 'CAMK2A', 'CAV1', 'CAV2', 'CBL', 'CBLB', 'CBLC', 'CDC42', 'CFL1', 'CREB1', 'CRK', 'CRKL', 'CSK', 'DNM1', 'DOK2', 'E2F1', 'EGF', 'EGFR', 'EIF4EBP1', 'ELK1', 'ELK4', 'EPN1', 'EPS15', 'EPS15L1', 'EPS8', 'ERBB2', 'ERRFI1', 'FOS', 'FOSB', 'FOXO1', 'FOXO4', 'GAB1', 'GAB2', 'GJA1', 'GRB10', 'GRB2', 'HGS', 'HRAS', 'INPP5D', 'INPPL1', 'IQGAP1', 'IQSEC1', 'ITCH', 'JAK1', 'JAK2', 'JUN', 'JUND', 'KRAS', 'LIMK2', 'MAP2K1', 'MAP2K2', 'MAP2K5', 'MAP3K1', 'MAP3K2', 'MAP3K3', 'MAP3K4', 'MAP4K1', 'MAPK1', 'MAPK14', 'MAPK4', 'MAPK7', 'MAPK8', 'MAPK9', 'MEF2A', 'MEF2C', 'MEF2D', 'MT-CO2', 'MTOR', 'MYBL2', 'NCK1', 'NCK2', 'NCOA3', 'NDUFA13', 'NEDD4', 'NEDD8', 'NOS3', 'PAK1', 'PCNA', 'PDPK1', 'PEBP1', 'PIAS3', 'PIK3C2B', 'PIK3R1', 'PIK3R2', 'PLCE1', 'PLCG1', 'PLD1', 'PLD2', 'PLSCR1', 'PRKCA', 'PRKCB', 'PRKCD', 'PRKCI', 'PRKCZ', 'PTEN', 'PTK2', 'PTK2B', 'PTK6', 'PTPN11', 'PTPN12', 'PTPN5', 'PTPRR', 'PXDN', 'RAB5A', 'RAC1', 'RAF1', 'RALA', 'RALB', 'RALBP1', 'RALGDS', 'RAP1A', 'RASA1', 'REPS2', 'RICTOR', 'RIN1', 'ROCK1', 'RPS6KA1', 'RPS6KA2', 'RPS6KA3', 'RPS6KA5', 'RPS6KB1', 'SH2D2A', 'SH3GL2', 'SH3GL3', 'SH3KBP1', 'SHC1', 'SOS1', 'SOS2', 'SP1', 'SPRY2', 'SRC', 'STAM', 'STAM2', 'STAMBP', 'STAT1', 'STAT3', 'STAT5A', 'STAT5B', 'STMN1', 'STXBP1', 'SYNJ1', 'TNK2', 'TWIST1', 'USP6NL', 'USP8', 'VAV1', 'VAV2', 'VAV3']\nNodes founded:  ['ABI1', 'ABL1', 'AKT1', 'ARF6', 'ASAP1', 'BCAR1', 'CAMK2A', 'CAV1', 'CBL', 'CBLB', 'CBLC', 'CDC42', 'CRK', 'CRKL', 'CSK', 'EGF', 'EGFR', 'EIF4EBP1', 'ELK4', 'EPN1', 'EPS15', 'EPS15L1', 'GAB1', 'GAB2', 'GRB10', 'GRB2', 'HGS', 'HRAS', 'INPP5D', 'IQGAP1', 'JAK1', 'JAK2', 'KRAS', 'MAP2K1', 'MAP3K4', 'MAPK1', 'MAPK14', 'MAPK7', 'MAPK8', 'MTOR', 'NCK1', 'NCK2', 'PAK1', 'PEBP1', 'PIK3R1', 'PIK3R2', 'PLCG1', 'PLD1', 'PRKCA', 'PRKCD', 'PRKCZ', 'PTEN', 'PTK2', 'PTK2B', 'PTPN11', 'PTPN12', 'PTPRR', 'RAC1', 'RAF1', 'RALGDS', 'RAP1A', 'RASA1', 'RICTOR', 'RIN1', 'ROCK1', 'RPS6KA5', 'RPS6KB1', 'SH3GL2', 'SHC1', 'SOS1', 'SRC', 'USP6NL', 'VAV1', 'VAV2', 'VAV3']\n</pre> In\u00a0[37]: Copied! <pre>print(\"Percentage of genes covered: \", (len(nodes_found)/len(egf_egfr_genes)) * 100)\n</pre> print(\"Percentage of genes covered: \", (len(nodes_found)/len(egf_egfr_genes)) * 100) <pre>Percentage of genes covered:  46.2962962962963\n</pre> <p>Once more, the INE captured better the pathway composition, recovering 40-50% of the genes in the EGF/EGFR pathway from wikipathways (by starting from 10%). This time, INE performed better than RPE. The reason for this resides within the database composition. The Omnipath database contains tons of interaction, which means, many possibilities to go from gene A to gene B in the shortest path possible (with max len = 3). On the other hand, INE runs with max_len = 1, so it just collects all the possible neighbors of the nodes, without looking for extended extra pathways.</p> <p>Please remember that the aim of the RPE algorithm is to reduce as much as possible the average network distance. On the other hand, the INE algorithm does not care about it.</p>"},{"location":"tutorials/9-Recreating_famous_pathways/#re-creating-famous-pathways-from-signor-and-wikipathways-using-neko","title":"Re-creating famous pathways from SIGNOR and WIKIPATHWAYS using NeKo\u00b6","text":""},{"location":"tutorials/9-Recreating_famous_pathways/#1-retrieving-the-mtor-signaling-from-signor-using-neko","title":"1) Retrieving the MTOR Signaling from Signor using NeKo\u00b6","text":""},{"location":"tutorials/9-Recreating_famous_pathways/","title":"\u00b6","text":"<p>Note</p> <p>The max_len in the function connect_network_radially should be kept at 1, max 2. Why?</p> <p>The Iterative Neighbour Expansion, as the name suggests, iterates through all the seed nodes and adds to the network all the interactions found. In the next step, it iterates through all the neighbors found and looks for their neighbors. Doing so, the Network size could exponentially increase, if among the neighbor nodes there are some HUB (nodes with a high degree of connection).</p>"},{"location":"tutorials/9-Recreating_famous_pathways/#2-retrieving-the-egfegfr-pathway-source-wikipathway-using-omnipath","title":"2) Retrieving the EGF/EGFR pathway (source: wikipathway) using Omnipath\u00b6","text":""},{"location":"tutorials/9-Recreating_famous_pathways/","title":"\u00b6","text":"<p>TIP</p> <p>NeKo provides some built-in functions to easily plug some well-known databases, like Omnipath, Signor, PhosphositePlus and Huri. More information can be found in the Notebook #2</p>"}]}